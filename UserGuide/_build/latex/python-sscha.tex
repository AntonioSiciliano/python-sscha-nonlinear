%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{python-sscha Documentation}
\date{Feb 15, 2023}
\release{1.2}
\author{Lorenzo Monacelli}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index1::doc}}


\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{intro:introduction}}\label{\detokenize{intro::doc}}

\section{What is python\sphinxhyphen{}sscha?}
\label{\detokenize{intro:what-is-python-sscha}}
\sphinxAtStartPar
python\sphinxhyphen{}sscha is both a python library and a stand\sphinxhyphen{}alone program to simulate quantum and thermal fluctuations in solid systems.


\section{Why do I need python\sphinxhyphen{}sscha?}
\label{\detokenize{intro:why-do-i-need-python-sscha}}
\sphinxAtStartPar
If you are simulating transport or thermal properties of materials, phase diagrams, or phonon\sphinxhyphen{}related properties of materials, you need python\sphinxhyphen{}sscha.
It is a package that enables you to include the effect of both thermal and quantum phonon fluctuations into your \sphinxstyleemphasis{ab initio} simulations.

\sphinxAtStartPar
The method used by this package is the  Stochastic self\sphinxhyphen{}consistent Harmonic Approximation (SSCHA). The SSCHA is a full\sphinxhyphen{}quantum method that optimizes the nuclear wave\sphinxhyphen{}function (or density matrix at finite temperature) to minimize the free energy.
In this way, you can simulate highly anharmonic systems, like those close to a second\sphinxhyphen{}order phase transition (as charge density waves and thermoelectric materials).
Despite the full quantum and thermal nature of the algorithm, the overall computational cost is comparable to standard classical molecular dynamics. Since the algorithm correctly exploits the symmetries of the crystal, it is also much cheaper.

\sphinxAtStartPar
python\sphinxhyphen{}sscha comes both as a python library that can be run inside your workflows and as stand\sphinxhyphen{}alone software, initialized by input scripts with the same syntax as Quantum ESPRESSO.

\sphinxAtStartPar
You can couple it with any \sphinxstyleemphasis{ab initio} engine for force and energy calculations. It can interact through the Atomic Simulation Environment (ASE) and has an implemented interface for automatic submission of jobs in a remote cluster.

\sphinxAtStartPar
Moreover, it is easy to use, with short input files highly human\sphinxhyphen{}readable.
What are you waiting for? Download and install python\sphinxhyphen{}sscha, and start enjoying the Tutorials!

\sphinxstepscope


\chapter{How to install}
\label{\detokenize{install:how-to-install}}\label{\detokenize{install::doc}}
\sphinxAtStartPar
The SSCHA code is a collection of 2 python packages: CellConstructor and python\sphinxhyphen{}sscha.
In this guide, we refer to the installation of python\sphinxhyphen{}sscha.


\section{Requirements}
\label{\detokenize{install:requirements}}
\sphinxAtStartPar
To install python\sphinxhyphen{}sscha you need:
1. python (either 2.7 or 3.*)
2. numpy
3. scipy
4. matplotlib
5. Lapack
6. Blas
7. gfortran (or any fortran compiler)
8. CellConstructor

\sphinxAtStartPar
For python, we strongly recommend using the anaconda distribution, that already comes with numerical packages correctly compiled to exploit multithreading.

\sphinxAtStartPar
The numpy, scipy and matplotlib are python packages. These are usually provided with a new installation
of python distributions like anaconda. Lapack and Blas are needed for compiling the FORTRAN code (together with a FORTRAN compiler like gfortran).
In many Linux distributions like ubuntu they can be installed as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{sudo apt\PYGZhy{}get install libblas\PYGZhy{}dev liblapack\PYGZhy{}dev liblapacke\PYGZhy{}dev gfortran}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that this specific command may change in time.

\sphinxAtStartPar
Together with these mandatory requirements (otherwise, the code will not compile correctly or raise an exception at the startup), we
strongly recommend installing also the following libraries:
1. Atomic Simulation Environment (ASE)
2. SPGLIB

\sphinxAtStartPar
If these packages are available, they will enable the automatic cluster/local calculation of forces (ASE) and the symmetry recognition in the supercell (SPGLIB).

\sphinxAtStartPar
To install all the python dependencies (and recommended) automatically, you may just run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{pip install \PYGZhy{}r requirements.txt}
\end{sphinxVerbatim}


\section{Installation from pip}
\label{\detokenize{install:installation-from-pip}}
\sphinxAtStartPar
The easiest way to install python\sphinxhyphen{}sscha (and CellConstructor) is through the python package manager:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{pip install python\PYGZhy{}sscha}
\end{sphinxVerbatim}

\sphinxAtStartPar
Eventually, you can append the \textendash{}user option to install the package only for the user (without requiring administrator powers).
Pip will check for requirements automatically and install them. This method only works if pip is already installed with python.


\section{Installation from source}
\label{\detokenize{install:installation-from-source}}
\sphinxAtStartPar
Once all the dependences of the codes are satisfied, you can unzip the source code downloaded from the website.
Then run, inside the directory that contains the setup.py script, the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{python setup.py install}
\end{sphinxVerbatim}

\sphinxAtStartPar
As for the pip installation, you may append the \textendash{}user option to install the package only for the user (without requiring administrator powers).


\section{Install with Intel FORTRAN compiler}
\label{\detokenize{install:install-with-intel-fortran-compiler}}
\sphinxAtStartPar
The setup.py script works automatically with the GNU FORTRAN compiler. However, due to some differences in linking lapack,
to use the intel compiler you need to edit a bit the setup.py script:

\sphinxAtStartPar
In this case, you need to delete the lapack linking from the
setup.py and include the \sphinxhyphen{}mkl as linker option.
Note that you must force to use the same liker compiler as the one used for the compilation.


\section{Install with a specific compiler path}
\label{\detokenize{install:install-with-a-specific-compiler-path}}
\sphinxAtStartPar
This can be achieved by specifying the environment variables on which setup.py relies:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
CC (C compiler)

\item {} 
\sphinxAtStartPar
FC (Fortran compiler)

\item {} 
\sphinxAtStartPar
LDSHARED (linking)

\end{enumerate}

\sphinxAtStartPar
If we want to use a custom compiler in /path/to/fcompiler we may run the setup as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{FC=/path/to/fcompiler LDSHARED=/path/to/fcompiler python setup.py install}
\end{sphinxVerbatim}

\sphinxAtStartPar
A specific setup.py script is provided to install it easily in FOSS clusters.

\sphinxstepscope


\chapter{Quick start}
\label{\detokenize{start:quick-start}}\label{\detokenize{start::doc}}
\sphinxAtStartPar
In this chapter we provide ready to use examples to setup your first SSCHA calculation.


\section{The free energy of gold: a simulation in the NVT ensemble}
\label{\detokenize{start:the-free-energy-of-gold-a-simulation-in-the-nvt-ensemble}}
\sphinxAtStartPar
This simple tutorial explains how to setup a SSCHA calculation starting just from the structure, in this case a cif file we downloaded from the {[}Materials Project{]}(\sphinxurl{https://materialsproject.org/materials/mp-81/}) database.

\sphinxAtStartPar
You can find there a lot of structures ready to use for your SSCHA runs.

\sphinxAtStartPar
For the purpouse of this tutorial, we are going to use the EMT force field, so that the calculation can be run in a laptop without the need of a supercomputer.
We explain in a later section how to couple the SSCHA with a cluster to submit the same calculation fully ab\sphinxhyphen{}initio.
\begin{description}
\sphinxlineitem{Starting from the Gold structure in the primitive cell, to run the SSCHA we need:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Compute the harmonic phonons (dynamical matrix)

\item {} 
\sphinxAtStartPar
Remove imaginary frequencies (if any)

\item {} 
\sphinxAtStartPar
Run the SSCHA

\end{itemize}

\end{description}

\sphinxAtStartPar
We prepared an input file in the form of a python script (tested with python\sphinxhyphen{}sscha version 1.2) which makes all these passages automatically.

\sphinxAtStartPar
You find a copy of the script and the cif file of Gold inside the directory Examples/ThermodynamicsOfGold

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import the sscha code}
\PYG{k+kn}{import} \PYG{n+nn}{sscha}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Ensemble}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{SchaMinimizer}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Relax}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Utilities}

\PYG{c+c1}{\PYGZsh{} Import the cellconstructor library to manage phonons}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor} \PYG{k}{as} \PYG{n+nn}{CC}\PYG{o}{,} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{Phonons}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{Structure}\PYG{o}{,} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{calculators}

\PYG{c+c1}{\PYGZsh{} Import the force field of Gold}
\PYG{k+kn}{import} \PYG{n+nn}{ase}\PYG{o}{,} \PYG{n+nn}{ase}\PYG{n+nn}{.}\PYG{n+nn}{calculators}
\PYG{k+kn}{from} \PYG{n+nn}{ase}\PYG{n+nn}{.}\PYG{n+nn}{calculators}\PYG{n+nn}{.}\PYG{n+nn}{emt} \PYG{k+kn}{import} \PYG{n}{EMT}

\PYG{c+c1}{\PYGZsh{} Import numerical and general pourpouse libraries}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}\PYG{o}{,} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{sys}\PYG{o}{,} \PYG{n+nn}{os}


\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Here we load the primitive cell of Gold from a cif file.}
\PYG{l+s+sd}{And we use CellConstructor to compute phonons from finite differences.}
\PYG{l+s+sd}{The phonons are computed on a q\PYGZhy{}mesh 4x4x4}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{gold\PYGZus{}structure} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Structure}\PYG{o}{.}\PYG{n}{Structure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{gold\PYGZus{}structure}\PYG{o}{.}\PYG{n}{read\PYGZus{}generic\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Au.cif}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Get the force field for gold}
\PYG{n}{calculator} \PYG{o}{=} \PYG{n}{EMT}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Relax the gold structure (useless since for symmetries it is already relaxed)}
\PYG{n}{relax} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{calculators}\PYG{o}{.}\PYG{n}{Relax}\PYG{p}{(}\PYG{n}{gold\PYGZus{}structure}\PYG{p}{,} \PYG{n}{calculator}\PYG{p}{)}
\PYG{n}{gold\PYGZus{}structure\PYGZus{}relaxed} \PYG{o}{=} \PYG{n}{relax}\PYG{o}{.}\PYG{n}{static\PYGZus{}relax}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compute the harmonic phonons}
\PYG{c+c1}{\PYGZsh{} NOTE: if the code is run with mpirun, the calculation goes in parallel}
\PYG{n}{gold\PYGZus{}harmonic\PYGZus{}dyn} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Phonons}\PYG{o}{.}\PYG{n}{compute\PYGZus{}phonons\PYGZus{}finite\PYGZus{}displacements}\PYG{p}{(}\PYG{n}{gold\PYGZus{}structure\PYGZus{}relaxed}\PYG{p}{,} \PYG{n}{calculator}\PYG{p}{,} \PYG{n}{supercell} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Impose the symmetries and}
\PYG{c+c1}{\PYGZsh{} save the dynamical matrix in the quantum espresso format}
\PYG{n}{gold\PYGZus{}harmonic\PYGZus{}dyn}\PYG{o}{.}\PYG{n}{Symmetrize}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{gold\PYGZus{}harmonic\PYGZus{}dyn}\PYG{o}{.}\PYG{n}{save\PYGZus{}qe}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{harmonic\PYGZus{}dyn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} If the dynamical matrix has imaginary frequencies, remove them}
\PYG{n}{gold\PYGZus{}harmonic\PYGZus{}dyn}\PYG{o}{.}\PYG{n}{ForcePositiveDefinite}\PYG{p}{(}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{gold\PYGZus{}harmonic\PYGZus{}dyn is ready to start the SSCHA calculation.}

\PYG{l+s+sd}{Now let us initialize the ensemble, and the calculation at 300 K.}
\PYG{l+s+sd}{We will run a NVT calculation, using 100 configurations at each step}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{TEMPERATURE} \PYG{o}{=} \PYG{l+m+mi}{300}
\PYG{n}{N\PYGZus{}CONFIGS} \PYG{o}{=} \PYG{l+m+mi}{50}
\PYG{n}{MAX\PYGZus{}ITERATIONS} \PYG{o}{=} \PYG{l+m+mi}{20}

\PYG{c+c1}{\PYGZsh{} Initialize the random ionic ensemble}
\PYG{n}{ensemble} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{p}{(}\PYG{n}{gold\PYGZus{}harmonic\PYGZus{}dyn}\PYG{p}{,} \PYG{n}{TEMPERATURE}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the free energy minimizer}
\PYG{n}{minim} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{SchaMinimizer}\PYG{o}{.}\PYG{n}{SSCHA\PYGZus{}Minimizer}\PYG{p}{(}\PYG{n}{ensemble}\PYG{p}{)}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{set\PYGZus{}minimization\PYGZus{}step}\PYG{p}{(}\PYG{l+m+mf}{0.01}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the NVT simulation}
\PYG{n}{relax} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Relax}\PYG{o}{.}\PYG{n}{SSCHA}\PYG{p}{(}\PYG{n}{minim}\PYG{p}{,} \PYG{n}{calculator}\PYG{p}{,} \PYG{n}{N\PYGZus{}configs} \PYG{o}{=} \PYG{n}{N\PYGZus{}CONFIGS}\PYG{p}{,}
\PYG{n}{max\PYGZus{}pop} \PYG{o}{=} \PYG{n}{MAX\PYGZus{}ITERATIONS}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define the I/O operations}
\PYG{c+c1}{\PYGZsh{} To save info about the free energy minimization after each step}
\PYG{n}{ioinfo} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Utilities}\PYG{o}{.}\PYG{n}{IOInfo}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ioinfo}\PYG{o}{.}\PYG{n}{SetupSaving}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{minim\PYGZus{}info}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{setup\PYGZus{}custom\PYGZus{}functions}\PYG{p}{(}\PYG{n}{custom\PYGZus{}function\PYGZus{}post} \PYG{o}{=} \PYG{n}{ioinfo}\PYG{o}{.}\PYG{n}{CFP\PYGZus{}SaveAll}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Run the NVT simulation (save the stress to compute the pressure)}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{relax}\PYG{p}{(}\PYG{n}{get\PYGZus{}stress} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} If instead you want to run a NPT simulation, use}
\PYG{c+c1}{\PYGZsh{} The target pressure is given in GPa.}
\PYG{c+c1}{\PYGZsh{}relax.vc\PYGZus{}relax(target\PYGZus{}press = 0)}

\PYG{c+c1}{\PYGZsh{} You can also run a mixed simulation (NVT) but with variable lattice parameters}
\PYG{c+c1}{\PYGZsh{}relax.vc\PYGZus{}relax(fix\PYGZus{}volume = True)}

\PYG{c+c1}{\PYGZsh{} Now we can save the final dynamical matrix}
\PYG{c+c1}{\PYGZsh{} And print in stdout the info about the minimization}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{minim}\PYG{o}{.}\PYG{n}{finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{minim}\PYG{o}{.}\PYG{n}{dyn}\PYG{o}{.}\PYG{n}{save\PYGZus{}qe}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sscha\PYGZus{}T}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZus{}dyn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{TEMPERATURE}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now save the file as \sphinxtitleref{sscha\_gold.py} and execute it with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python sscha\PYGZus{}gold.py \PYGZgt{} output.log
\end{sphinxVerbatim}

\sphinxAtStartPar
And that’s it. The code will probably take few minutes on a standard laptop computer.
\sphinxstylestrong{Congratulations!} You run your first SSCHA simulation!

\sphinxAtStartPar
If you open a new terminal in the same directory of the SSCHA submission, you can plot the info during the minimization.
Starting from version 1.2, we provide a visualization utilities installed together with the SSCHA.
Simply type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sscha\PYGZhy{}plot\PYGZhy{}data.py minim\PYGZus{}info
\end{sphinxVerbatim}

\sphinxAtStartPar
You will see two windows.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{gold_minim}.png}
\caption{Minimization data of Gold.}\label{\detokenize{start:id1}}\label{\detokenize{start:fig-goldminim}}\end{figure}

\sphinxAtStartPar
In \hyperref[\detokenize{start:fig-goldminim}]{Fig.\@ \ref{\detokenize{start:fig-goldminim}}} we have all the minimization data. On the top\sphinxhyphen{}left panel, we see the free energy. As expected, it decreases (since the SSCHA is minimizing it).
You can see that at certain values of the steps there are discontinuities.
These occurs when the code realizes that the ensemble on which it is computing is no more good and a new one is generated. The goodness of an ensemble is determined by the Kong\sphinxhyphen{}Liu effective sample size (bottom\sphinxhyphen{}left).
When it reaches 0.5 of its initial value (equal to the number of configurations), the ensemble is extracted again and a new iteration starts. You see that in the last iteration, the code stops before getting to 25 (\(0.5\cdot 50\)). This means that the code converged properly: the gradient reached zero when the ensemble was still good.

\sphinxAtStartPar
On the right\sphinxhyphen{}side you see the free energy gradients, which must go to zero to converge. The top\sphinxhyphen{}right is the gradient of the SSCHA dynamical matrix, while on bottom\sphinxhyphen{}right there is the gradient of the average atomic positions.

\sphinxAtStartPar
Indeed, since the gold atomic positions are all fixed by symmetries, it is always zero (but it will be different from zero in more complex system).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{frequency_minim}.png}
\caption{All the SSCHA phonon frequencies as a function of the step in the NVT simulation.}\label{\detokenize{start:id2}}\label{\detokenize{start:fig-goldfreqs}}\end{figure}

\sphinxAtStartPar
Instead, \hyperref[\detokenize{start:fig-goldfreqs}]{Fig.\@ \ref{\detokenize{start:fig-goldfreqs}}} represents the evolution of the SSCHA phonon frequencies.
Here, all the frequencies in the supercell (at each q point commensurate with the calculation) are shown.

\sphinxAtStartPar
By looking at how they change you can have an idea on which phonon mode are more affected by anharmonicity. In this case, it is evident that Gold is trongly anharmonci and that the finite temperature tend to harden almost all the phonon frequencies.

\sphinxAtStartPar
At the end of the simulation, the code writes the final dynamical matrix in the quantum espresso file format: \sphinxstyleemphasis{sscha\_T300\_dynX} where X goes over the number of irreducible q points.

\sphinxAtStartPar
In the next section, we analyze in details each section of the script to provide a bit more insight on the simulation, and a guide to modify it to fit your needs and submit your own system.


\section{Plot the phonon dispersion}
\label{\detokenize{start:plot-the-phonon-dispersion}}
\sphinxAtStartPar
Now that the SSCHA minimization ended, we can compare the harmonic and anharmonic phonon dispersion of Gold.

\sphinxAtStartPar
To this purpouse, we can simply run a script like the following. You find a copy of this script already in Examples/ThermodynamicsOfGold/plot\_dispersion.py.

\sphinxAtStartPar
You can use it even in your simulation, simply edit the value of the uppercase keyword at the beginning of the script to match your needs.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import the CellConstructor library to plot the dispersion}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor} \PYG{k}{as} \PYG{n+nn}{CC}\PYG{o}{,} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{Phonons}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{ForceTensor}

\PYG{c+c1}{\PYGZsh{} Import the numerical libraries and those for plotting}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k+kn}{import} \PYG{n+nn}{sys}\PYG{o}{,} \PYG{n+nn}{os}

\PYG{c+c1}{\PYGZsh{} Let us define the PATH in the brilluin zone and the total number of points}
\PYG{n}{PATH} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GXWXKGL}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{N\PYGZus{}POINTS} \PYG{o}{=} \PYG{l+m+mi}{1000}

\PYG{c+c1}{\PYGZsh{} Here we define the position of the special points}
\PYG{n}{SPECIAL\PYGZus{}POINTS} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{G}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{.5}\PYG{p}{,} \PYG{l+m+mf}{.5}\PYG{p}{]}\PYG{p}{,}
             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{.5}\PYG{p}{,} \PYG{l+m+mf}{.5}\PYG{p}{,} \PYG{l+m+mf}{.5}\PYG{p}{]}\PYG{p}{,}
             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{W}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{.25}\PYG{p}{,} \PYG{l+m+mf}{.75}\PYG{p}{,} \PYG{l+m+mf}{.5}\PYG{p}{]}\PYG{p}{,}
             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{K}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mf}{8.}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mf}{8.}\PYG{p}{]}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} The two dynamical matrix to be compared}
\PYG{n}{HARM\PYGZus{}DYN} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{harmonic\PYGZus{}dyn}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{SSCHA\PYGZus{}DYN} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sscha\PYGZus{}T300\PYGZus{}dyn}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} The number of irreducible q points}
\PYG{c+c1}{\PYGZsh{} i.e., the number of files in which the phonons are stored}
\PYG{n}{NQIRR} \PYG{o}{=} \PYG{l+m+mi}{13}


\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} THE SCRIPT FOLLOWS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZsh{} Load the harmonic and sscha phonons}
\PYG{n}{harmonic\PYGZus{}dyn} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Phonons}\PYG{o}{.}\PYG{n}{Phonons}\PYG{p}{(}\PYG{p}{,} \PYG{n}{NQIRR}\PYG{p}{)}
\PYG{n}{sscha\PYGZus{}dyn} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Phonons}\PYG{o}{.}\PYG{n}{Phonons}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sscha\PYGZus{}T300\PYGZus{}dyn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{NQIRR}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Get the band path}
\PYG{n}{qpath}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Methods}\PYG{o}{.}\PYG{n}{get\PYGZus{}bandpath}\PYG{p}{(}\PYG{n}{harmonic\PYGZus{}dyn}\PYG{o}{.}\PYG{n}{structure}\PYG{o}{.}\PYG{n}{unit\PYGZus{}cell}\PYG{p}{,}
             \PYG{n}{PATH}\PYG{p}{,}
             \PYG{n}{SPECIAL\PYGZus{}POINTS}\PYG{p}{,}
             \PYG{n}{N\PYGZus{}POINTS}\PYG{p}{)}
\PYG{n}{xaxis}\PYG{p}{,} \PYG{n}{xticks}\PYG{p}{,} \PYG{n}{xlabels} \PYG{o}{=} \PYG{n}{data} \PYG{c+c1}{\PYGZsh{} Info to plot correclty the x axis}

\PYG{c+c1}{\PYGZsh{} Get the phonon dispersion along the path}
\PYG{n}{harmonic\PYGZus{}dispersion} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{ForceTensor}\PYG{o}{.}\PYG{n}{get\PYGZus{}phonons\PYGZus{}in\PYGZus{}qpath}\PYG{p}{(}\PYG{n}{harmonic\PYGZus{}dyn}\PYG{p}{,} \PYG{n}{qpath}\PYG{p}{)}
\PYG{n}{sscha\PYGZus{}dispersion} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{ForceTensor}\PYG{o}{.}\PYG{n}{get\PYGZus{}phonons\PYGZus{}in\PYGZus{}qpath}\PYG{p}{(}\PYG{n}{sscha\PYGZus{}dyn}\PYG{p}{,} \PYG{n}{qpath}\PYG{p}{)}

\PYG{n}{nmodes} \PYG{o}{=} \PYG{n}{harmonic\PYGZus{}dyn}\PYG{o}{.}\PYG{n}{structure}\PYG{o}{.}\PYG{n}{N\PYGZus{}atoms} \PYG{o}{*} \PYG{l+m+mi}{3}

\PYG{c+c1}{\PYGZsh{} Plot the two dispersions}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{dpi} \PYG{o}{=} \PYG{l+m+mi}{150}\PYG{p}{)}
\PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nmodes}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lbl}\PYG{o}{=}\PYG{k+kc}{None}
    \PYG{n}{lblsscha} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{lbl} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Harmonic}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{lblsscha} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SSCHA}\PYG{l+s+s1}{\PYGZsq{}}

    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xaxis}\PYG{p}{,} \PYG{n}{harmonic\PYGZus{}dispersion}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dashed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{n}{lbl}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xaxis}\PYG{p}{,} \PYG{n}{sscha\PYGZus{}dispersion}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{n}{lblsscha}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot vertical lines for each high symmetry points}
\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{xticks}\PYG{p}{:}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axvline}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{lw} \PYG{o}{=} \PYG{l+m+mf}{0.4}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ls} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw} \PYG{o}{=} \PYG{l+m+mf}{0.4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set the x labels to the high symmetry points}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{n}{xticks}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticklabels}\PYG{p}{(}\PYG{n}{xlabels}\PYG{p}{)}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q path}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Phonons [cm\PYGZhy{}1]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dispersion.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If we save the script as \sphinxtitleref{plot\_dispersion.py} in the same directory of the calculation, we can run it with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python plot\PYGZus{}dispersion.py
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=450\sphinxpxdimen]{{gold_dispersion}.png}
\caption{Comparison between the SSCHA and the harmonic phonon dispersion of Gold.}\label{\detokenize{start:id3}}\label{\detokenize{start:fig-dispersion}}\end{figure}

\sphinxAtStartPar
The script will plot the figure of the phonon dispersion \hyperref[\detokenize{start:fig-dispersion}]{Fig.\@ \ref{\detokenize{start:fig-dispersion}}}.
It is quite different from the experimental one because of the poor accuracy of the force field, however, the SSCHA results is much closer to the experimental value.


\section{Analysis of the input script for the NVT simulation}
\label{\detokenize{start:analysis-of-the-input-script-for-the-nvt-simulation}}
\sphinxAtStartPar
While the input may seem long, it is heavily commented, but lets go through it step by step.
At the very beginning, we simply import the sscha libraries, cellconstructor, the math libraries and the force field. This is done in python with the \sphinxtitleref{import} statemets.

\sphinxAtStartPar
The first real part of the code is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gold\PYGZus{}structure} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Structure}\PYG{o}{.}\PYG{n}{Structure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{gold\PYGZus{}structure}\PYG{o}{.}\PYG{n}{read\PYGZus{}generic\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Au.cif}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Get the force field for gold}
\PYG{n}{calculator} \PYG{o}{=} \PYG{n}{EMT}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Relax the gold structure (useless since for symmetries it is already relaxed)}
\PYG{n}{relax} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{calculators}\PYG{o}{.}\PYG{n}{Relax}\PYG{p}{(}\PYG{n}{gold\PYGZus{}structure}\PYG{p}{,} \PYG{n}{calculator}\PYG{p}{)}
\PYG{n}{gold\PYGZus{}structure\PYGZus{}relaxed} \PYG{o}{=} \PYG{n}{relax}\PYG{o}{.}\PYG{n}{static\PYGZus{}relax}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here we initialize a cellconstructor structure from the cif file downloaded from the material database (\sphinxstyleemphasis{Au.cif}). We initialize the EMT calculator from ASE, and relax the structure.

\sphinxAtStartPar
In the case of Gold the relaxation is useless, as it is a FCC structure with Fm\sphinxhyphen{}3m symmetry group and 1 atom per primitive cell. This means the atomic positions have no degrees of freedom, thus the relaxation will end before even start.

\sphinxAtStartPar
In the next part of the code, we perform the harmonic phonon calculation using cellconstructor and a finite displacement approach:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gold\PYGZus{}harmonic\PYGZus{}dyn} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Phonons}\PYG{o}{.}\PYG{n}{compute\PYGZus{}phonons\PYGZus{}finite\PYGZus{}displacements}\PYG{p}{(}\PYG{n}{gold\PYGZus{}structure\PYGZus{}relaxed}\PYG{p}{,} \PYG{n}{calculator}\PYG{p}{,} \PYG{n}{supercell} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Impose the symmetries and}
\PYG{c+c1}{\PYGZsh{} save the dynamical matrix in the quantum espresso format}
\PYG{n}{gold\PYGZus{}harmonic\PYGZus{}dyn}\PYG{o}{.}\PYG{n}{Symmetrize}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{gold\PYGZus{}harmonic\PYGZus{}dyn}\PYG{o}{.}\PYG{n}{save\PYGZus{}qe}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{harmonic\PYGZus{}dyn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} If the dynamical matrix has imaginary frequencies, remove them}
\PYG{n}{gold\PYGZus{}harmonic\PYGZus{}dyn}\PYG{o}{.}\PYG{n}{ForcePositiveDefinite}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The method \sphinxtitleref{compute\_phonons\_finite\_displacements} is documented in the CellConstructor guide. It requires the structure (in this case \sphinxtitleref{gold\_structure\_relaxed}), the force\sphinxhyphen{}field (\sphinxtitleref{calculator}) and the supercell for the calculation. In this case we use a 4x4x4 (equivalent to 64 atoms). This may not be sufficient to converge all the properties, especially at very high temperature, but it is just a start.

\sphinxAtStartPar
Note that  \sphinxtitleref{compute\_phonons\_finite\_displacements}  works in parallel with MPI, therefore, if the script is executed with \sphinxtitleref{mpirun \sphinxhyphen{}np 16 python myscript.py} it will split the calculations of the finite displacements across 16 processors. You need to have mpi4py installed.

\sphinxAtStartPar
After computing the harmonic phonons in gold\_harmonic\_dyn, we impose the correct symmetrization and the acousitic sum rule with the \sphinxtitleref{Symmetrize} method, and save the result in the quantum ESPRESSO format with \sphinxtitleref{save\_qe}.
This should not be the case for Gold, however, if we have a structure which has imaginary phonon frequencies, we need to get rid of them before starting the SSCHA. This is achieved with \sphinxtitleref{ForcePositiveDefinite} (see CellConstructor documentation for more details on how these methods work).

\sphinxAtStartPar
\sphinxstylestrong{Now we are ready to submit the SSCHA calculation in the NVT ensemble!}.
The important parameters are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The temperature

\item {} 
\sphinxAtStartPar
The number of random configurations in the ensemble

\item {} 
\sphinxAtStartPar
The maximum number of iterations

\end{itemize}

\sphinxAtStartPar
These parameters are almost self\sphinxhyphen{}explaining. However, we give a brief overview of how the SSCHA works to help you understand which are the best one for your case.
While MD or MC calculation represent the equilibrium probability distribution over time of the system by updating a single structure, the SSCHA encodes the whole probability distribution as an analytical function. Therefore, to compute properties, we can generate on the fly the ionic configurations that represent the equilibrium distributions.
The number of random configuration is exactly how many ionic configuration we generate to compute the properties (Free energy and Stress tensors)

\sphinxAtStartPar
The code that sets up and perform the SSCHA is the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TEMPERATURE} \PYG{o}{=} \PYG{l+m+mi}{300}
\PYG{n}{N\PYGZus{}CONFIGS} \PYG{o}{=} \PYG{l+m+mi}{50}
\PYG{n}{MAX\PYGZus{}ITERATIONS} \PYG{o}{=} \PYG{l+m+mi}{20}

\PYG{c+c1}{\PYGZsh{} Initialize the random ionic ensemble}
\PYG{n}{ensemble} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{p}{(}\PYG{n}{gold\PYGZus{}harmonic\PYGZus{}dyn}\PYG{p}{,} \PYG{n}{TEMPERATURE}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the free energy minimizer}
\PYG{n}{minim} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{SchaMinimizer}\PYG{o}{.}\PYG{n}{SSCHA\PYGZus{}Minimizer}\PYG{p}{(}\PYG{n}{ensemble}\PYG{p}{)}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{set\PYGZus{}minimization\PYGZus{}step}\PYG{p}{(}\PYG{l+m+mf}{0.01}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the NVT simulation}
\PYG{n}{relax} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Relax}\PYG{o}{.}\PYG{n}{SSCHA}\PYG{p}{(}\PYG{n}{minim}\PYG{p}{,} \PYG{n}{calculator}\PYG{p}{,} \PYG{n}{N\PYGZus{}configs} \PYG{o}{=} \PYG{n}{N\PYGZus{}CONFIGS}\PYG{p}{,}
\PYG{n}{max\PYGZus{}pop} \PYG{o}{=} \PYG{n}{MAX\PYGZus{}ITERATIONS}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define the I/O operations}
\PYG{c+c1}{\PYGZsh{} To save info about the free energy minimization after each step}
\PYG{n}{ioinfo} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Utilities}\PYG{o}{.}\PYG{n}{IOInfo}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ioinfo}\PYG{o}{.}\PYG{n}{SetupSaving}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{minim\PYGZus{}info}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{setup\PYGZus{}custom\PYGZus{}functions}\PYG{p}{(}\PYG{n}{custom\PYGZus{}function\PYGZus{}post} \PYG{o}{=} \PYG{n}{ioinfo}\PYG{o}{.}\PYG{n}{CFP\PYGZus{}SaveAll}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Run the NVT simulation}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{relax}\PYG{p}{(}\PYG{n}{get\PYGZus{}stress} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
So you see many classes. \sphinxtitleref{ensemble} represent the ensemble of ionic configurations. We initialize it with the dynamical matrix (which represent how much atoms fluctuate around the centroids) and the temperature.
\sphinxtitleref{minim} is a \sphinxtitleref{SSCHA\_Minimizer} object, which performs the free energy minimization. It contains all the info regarding the minimization algorithm, as the initial timestep (that here we set to 0.01). You can avoid setting the time\sphinxhyphen{}step, as the code will automatically guess the best value.
The \sphinxtitleref{relax} is a \sphinxtitleref{SSCHA} object: the class that takes care about the simulation and automatizes all the steps to perform a NVT or NPT calculation.
We pass the minimizer (which contains the ensemble with the temperature), the force\sphinxhyphen{}field (\sphinxtitleref{calculator}), the number of configurations \sphinxtitleref{N\_configs} and the maximum number of iterations.

\sphinxAtStartPar
In this example, most of the time is spent in the minimization, however, if we replace the force\sphinxhyphen{}field with ab\sphinxhyphen{}initio DFT, the time tu run the minimization is negligible with respect to the time to compute energies and forces on the ensemble configurations.
The total (maximum) number of energy/forces calculations is equal to the number of configurations times the number of iterations (passed through the \sphinxtitleref{max\_pop} argument).

\sphinxAtStartPar
The calculation is submitted with \sphinxtitleref{relax.relax()}. However, before running the calculation we introduce another object, the \sphinxtitleref{IOInfo}.
This tells the \sphinxtitleref{relax} to save information of the free energy, its gradient and the anharmonic phonon frequencies during the minimization in the files \sphinxstyleemphasis{minim\_info.dat° and *minim\_info.freqs}. It is not mandatory to introduce them, but it is very usefull as it allows to visualize the minimization while it is running.


\section{Exercise}
\label{\detokenize{start:exercise}}
\sphinxAtStartPar
Try to perform the simulation of Gold but at a different temperature, plot then the SSCHA phonon dispersion as a function of temperature.

\sphinxAtStartPar
How does the phonon bands behaves with temperature? Do they become more rigid (energy increases) or softer?


\section{Running in the NPT ensemble: simulating thermal expansion}
\label{\detokenize{start:running-in-the-npt-ensemble-simulating-thermal-expansion}}
\sphinxAtStartPar
Now that you have some experience with the NVT simulation we are ready for the next step: NPT,
or relaxing the lattice.

\sphinxAtStartPar
With python\sphinxhyphen{}sscha it is very easy to run NPT simulation, you simply have to replace the line of the NVT script with the target pressure for the simulation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Replace the line}
\PYG{c+c1}{\PYGZsh{} relax.relax(get\PYGZus{}stress = True)}
\PYG{c+c1}{\PYGZsh{} with}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{vc\PYGZus{}relax}\PYG{p}{(}\PYG{n}{target\PYGZus{}press} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
And that is all! The target pressure is expressed in GPa, in this case 0 is ambient conditions (1 atm = 0.0001 GPa)

\sphinxAtStartPar
You can also perform NVT simulation with variable lattice parameters: In this case the system will constrain the total volume to remain constant, but the lattice parameter will be optimized (if the system is not cubic and has some degrees of freedom, which is not the case for Gold).

\sphinxAtStartPar
The NVT ensemble with variable lattice parameters (cell shape) is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Replace the line}
\PYG{c+c1}{\PYGZsh{}    relax.vc\PYGZus{}relax(target\PYGZus{}press = 0)}
\PYG{c+c1}{\PYGZsh{} with}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{vc\PYGZus{}relax}\PYG{p}{(}\PYG{n}{fix\PYGZus{}volume} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Indeed, this is a NVT simulation, therefore there is no need to specify the target pressure.

\sphinxAtStartPar
The following script, we run the NPT ensemble at various temperatures, each time starting from the previous ensemble, to follow the volume thermal expansion of gold.

\sphinxAtStartPar
You can find the full script in Examples/ThermodynamicsOfGold/thermal\_expansion.py

\sphinxAtStartPar
This script assume you already performed the NVT calculation, so that we can start from that results, and avoid the harmonic calculation (It is always a good practice to start with NVT simulation and then run NPT from the final result).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import the sscha code}
\PYG{k+kn}{import} \PYG{n+nn}{sscha}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Ensemble}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{SchaMinimizer}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Relax}
\PYG{k+kn}{import} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Utilities}

\PYG{c+c1}{\PYGZsh{} Import the cellconstructor library to manage phonons}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor} \PYG{k}{as} \PYG{n+nn}{CC}\PYG{o}{,} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{Phonons}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{Structure}\PYG{o}{,} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{calculators}

\PYG{c+c1}{\PYGZsh{} Import the force field of Gold}
\PYG{k+kn}{import} \PYG{n+nn}{ase}\PYG{o}{,} \PYG{n+nn}{ase}\PYG{n+nn}{.}\PYG{n+nn}{calculators}
\PYG{k+kn}{from} \PYG{n+nn}{ase}\PYG{n+nn}{.}\PYG{n+nn}{calculators}\PYG{n+nn}{.}\PYG{n+nn}{emt} \PYG{k+kn}{import} \PYG{n}{EMT}

\PYG{c+c1}{\PYGZsh{} Import numerical and general pourpouse libraries}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}\PYG{o}{,} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{sys}\PYG{o}{,} \PYG{n+nn}{os}


\PYG{c+c1}{\PYGZsh{} Define the temperature range (in K)}
\PYG{n}{T\PYGZus{}START} \PYG{o}{=} \PYG{l+m+mi}{300}
\PYG{n}{T\PYGZus{}END} \PYG{o}{=} \PYG{l+m+mi}{1000}
\PYG{n}{DT} \PYG{o}{=} \PYG{l+m+mi}{50}

\PYG{n}{N\PYGZus{}CONFIGS} \PYG{o}{=} \PYG{l+m+mi}{50}
\PYG{n}{MAX\PYGZus{}ITERATIONS} \PYG{o}{=} \PYG{l+m+mi}{10}

\PYG{c+c1}{\PYGZsh{} Import the gold force field}
\PYG{n}{calculator} \PYG{o}{=} \PYG{n}{EMT}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Import the starting dynamical matrix (final result of get\PYGZus{}gold\PYGZus{}free\PYGZus{}energy.py)}
\PYG{n}{dyn} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Phonons}\PYG{o}{.}\PYG{n}{Phonons}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sscha\PYGZus{}T300\PYGZus{}dyn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nqirr} \PYG{o}{=} \PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create the directory on which to store the output}
\PYG{n}{DIRECTORY} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermal\PYGZus{}expansion}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{DIRECTORY}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermal\PYGZus{}expansion}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} We cycle over several temperatures}
\PYG{n}{t} \PYG{o}{=} \PYG{n}{T\PYGZus{}START}


\PYG{n}{volumes} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{temperatures} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{while} \PYG{n}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{T\PYGZus{}END}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Change the temperature}
    \PYG{n}{ensemble} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{p}{(}\PYG{n}{dyn}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}
    \PYG{n}{minim} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{SchaMinimizer}\PYG{o}{.}\PYG{n}{SSCHA\PYGZus{}Minimizer}\PYG{p}{(}\PYG{n}{ensemble}\PYG{p}{)}
    \PYG{n}{minim}\PYG{o}{.}\PYG{n}{set\PYGZus{}minimization\PYGZus{}step}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}

    \PYG{n}{relax} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Relax}\PYG{o}{.}\PYG{n}{SSCHA}\PYG{p}{(}\PYG{n}{minim}\PYG{p}{,} \PYG{n}{calculator}\PYG{p}{,} \PYG{n}{N\PYGZus{}configs} \PYG{o}{=} \PYG{n}{N\PYGZus{}CONFIGS}\PYG{p}{,}
                              \PYG{n}{max\PYGZus{}pop} \PYG{o}{=} \PYG{n}{MAX\PYGZus{}ITERATIONS}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Setup the I/O}
    \PYG{n}{ioinfo} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Utilities}\PYG{o}{.}\PYG{n}{IOInfo}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ioinfo}\PYG{o}{.}\PYG{n}{SetupSaving}\PYG{p}{(} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{DIRECTORY}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{minim\PYGZus{}t}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{relax}\PYG{o}{.}\PYG{n}{setup\PYGZus{}custom\PYGZus{}functions}\PYG{p}{(} \PYG{n}{custom\PYGZus{}function\PYGZus{}post} \PYG{o}{=} \PYG{n}{ioinfo}\PYG{o}{.}\PYG{n}{CFP\PYGZus{}SaveAll}\PYG{p}{)}


    \PYG{c+c1}{\PYGZsh{} Run the NPT simulation}
    \PYG{n}{relax}\PYG{o}{.}\PYG{n}{vc\PYGZus{}relax}\PYG{p}{(}\PYG{n}{target\PYGZus{}press} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Save the volume and temperature}
    \PYG{n}{volumes}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{relax}\PYG{o}{.}\PYG{n}{minim}\PYG{o}{.}\PYG{n}{dyn}\PYG{o}{.}\PYG{n}{structure}\PYG{o}{.}\PYG{n}{get\PYGZus{}volume}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{temperatures}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Start the next simulation from the converged value at this temperature}
    \PYG{n}{relax}\PYG{o}{.}\PYG{n}{minim}\PYG{o}{.}\PYG{n}{dyn}\PYG{o}{.}\PYG{n}{save\PYGZus{}qe}\PYG{p}{(} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{DIRECTORY}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sscha\PYGZus{}T}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZus{}dyn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{dyn} \PYG{o}{=} \PYG{n}{relax}\PYG{o}{.}\PYG{n}{minim}\PYG{o}{.}\PYG{n}{dyn}

    \PYG{c+c1}{\PYGZsh{} Print in standard output}
    \PYG{n}{relax}\PYG{o}{.}\PYG{n}{minim}\PYG{o}{.}\PYG{n}{finalize}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Update the temperature}
    \PYG{n}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{DT}

    \PYG{c+c1}{\PYGZsh{} Save the thermal expansion}
    \PYG{n}{np}\PYG{o}{.}\PYG{n}{savetxt}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{DIRECTORY}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermal\PYGZus{}expansion.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
               \PYG{n}{np}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{p}{[}\PYG{n}{temperatures}\PYG{p}{,} \PYG{n}{volumes}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
               \PYG{n}{header} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Temperature [K]; Volume [A\PYGZca{}3]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can run the script as always with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python thermal\PYGZus{}expansion.py
\end{sphinxVerbatim}

\sphinxAtStartPar
And … done!

\sphinxAtStartPar
This calculation is going to require a bit more time, as we run multiple SSCHA at several temperatures.
After it finishes, you can plot the results written in the file thermal\_expansion/thermal\_expansion.dat.

\sphinxAtStartPar
A simple script to plot the thermal expansion (and fit the volumetric thermal expansion value) is the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k+kn}{import} \PYG{n+nn}{scipy}\PYG{o}{,} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{optimize}


\PYG{c+c1}{\PYGZsh{} Load all the dynamical matrices and compute volume}
\PYG{n}{DIRECTORY} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermal\PYGZus{}expansion}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{FILE} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{DIRECTORY}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermal\PYGZus{}expansion.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the data from the final data file}
\PYG{n}{temperatures}\PYG{p}{,} \PYG{n}{volumes} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{n}{FILE}\PYG{p}{,} \PYG{n}{unpack} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Prepare the figure and plot the V(T) from the sscha data}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{dpi} \PYG{o}{=} \PYG{l+m+mi}{150}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{,} \PYG{n}{volumes}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SSCHA data}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Fit the data to estimate the volumetric thermal expansion coefficient}
\PYG{k}{def} \PYG{n+nf}{parabola}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{n}{x} \PYG{o}{+} \PYG{n}{c}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{def} \PYG{n+nf}{diff\PYGZus{}parab}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{b} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n}{x}

\PYG{n}{popt}\PYG{p}{,} \PYG{n}{pcov} \PYG{o}{=} \PYG{n}{scipy}\PYG{o}{.}\PYG{n}{optimize}\PYG{o}{.}\PYG{n}{curve\PYGZus{}fit}\PYG{p}{(}\PYG{n}{parabola}\PYG{p}{,} \PYG{n}{temperatures}\PYG{p}{,} \PYG{n}{volumes}\PYG{p}{,}
                                      \PYG{n}{p0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Evaluate the volume thermal expansion}
\PYG{n}{vol\PYGZus{}thermal\PYGZus{}expansion} \PYG{o}{=} \PYG{n}{diff\PYGZus{}parab}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{o}{*}\PYG{n}{popt}\PYG{p}{)} \PYG{o}{/} \PYG{n}{parabola}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{o}{*}\PYG{n}{popt}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{text}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{alpha\PYGZus{}v = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}:.1f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{vol\PYGZus{}thermal\PYGZus{}expansion}\PYG{o}{*}\PYG{l+m+mf}{1e6}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{times 10\PYGZca{}6 \PYGZdl{} K\PYGZdl{}\PYGZca{}}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{\PYGZhy{}1\PYGZcb{}\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
         \PYG{n}{transform} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{transAxes}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Plot the fit}
\PYG{n}{\PYGZus{}t\PYGZus{}} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{\PYGZus{}t\PYGZus{}}\PYG{p}{,} \PYG{n}{parabola}\PYG{p}{(}\PYG{n}{\PYGZus{}t\PYGZus{}}\PYG{p}{,} \PYG{o}{*}\PYG{n}{popt}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Adjust the plot adding labels, legend, and saving in eps}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Temperature [K]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Volume [\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{AA\PYGZca{}3\PYGZdl{}]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{thermal\PYGZus{}expansion.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=450\sphinxpxdimen]{{thermal_expansion}.png}
\caption{Thermal expansion of Gold. From the fit of the data we can compute the volumetric
thermal expansion coefficient (at 300 K).}\label{\detokenize{start:id4}}\label{\detokenize{start:fig-goldexpansion}}\end{figure}

\sphinxAtStartPar
We report the final thermal expansion in \hyperref[\detokenize{start:fig-goldexpansion}]{Fig.\@ \ref{\detokenize{start:fig-goldexpansion}}}.
The volumetric expansion coefficient \(\alpha_v\) is obtained from the fit
thanks to the thermodynamic relation:
\begin{equation*}
\begin{split}\alpha_v = \frac{1}{V} \left(\frac{dV}{dT}\right)_P\end{split}
\end{equation*}
\sphinxAtStartPar
Also in this case, the result is quite off with experiments, due to the not completely realistic force\sphinxhyphen{}field employed. To get a more realistic approach, you should use \sphinxstyleemphasis{ab\sphinxhyphen{}initio} calculations or a more refined force\sphinxhyphen{}field.


\section{Ab initio calculation with the SSCHA code}
\label{\detokenize{start:ab-initio-calculation-with-the-sscha-code}}
\sphinxAtStartPar
The SSCHA code is compatible with the Atomic Simulation Environment (ASE), which we employed in the previous tutorial to get a fast force\sphinxhyphen{}field for Gold.

\sphinxAtStartPar
However, ASE already provides an interface with most codes to run ab initio simulations.
The simplest way of interfacing the SSCHA to an other ab initio code is to directly use ASE.

\sphinxAtStartPar
The only difference is in the definition of the calculator, in the first example of this chapter, the Gold force field was defined as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{ase}
\PYG{k+kn}{from} \PYG{n+nn}{ase}\PYG{n+nn}{.}\PYG{n+nn}{calculators}\PYG{n+nn}{.}\PYG{n+nn}{emt} \PYG{k+kn}{import} \PYG{n}{EMT}
\PYG{n}{calculator} \PYG{o}{=} \PYG{n}{EMT}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We simply need to replace these lines to our favourite DFT code. In this example we are going to use quantum espresso, but the procedure for VASP, CASTEP, CRYSTAL, ABINIT, SIESTA, or your favourite one are exatly the same (Refer to the official documentatio of ASE to the instruction on how to initialize these calculators).

\sphinxAtStartPar
In the case of DFT, unfortunately, we cannot simply create the calculator in one line, like we did for EMT force\sphinxhyphen{}field, as we need also to provide a lot of parameters, as pseudopotentials, the choice of exchange correlation, the cutoff of the basis set, and the k mesh grid for Brilluin zone sampling.

\sphinxAtStartPar
In the following example, we initialize the quantum espresso calculator for Gold.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{calculators}

\PYG{c+c1}{\PYGZsh{} Initialize the DFT (Quantum Espresso) calculator for gold}
\PYG{c+c1}{\PYGZsh{} The input data is a dictionary that encodes the pw.x input file namelist}
\PYG{n}{input\PYGZus{}data} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{control}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{\PYGZsh{} Avoid writing wavefunctions on the disk}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{disk\PYGZus{}io}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{None}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{c+c1}{\PYGZsh{} Where to find the pseudopotential}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pseudo\PYGZus{}dir}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{system}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{\PYGZsh{} Specify the basis set cutoffs}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ecutwfc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+m+mi}{45}\PYG{p}{,}   \PYG{c+c1}{\PYGZsh{} Cutoff for wavefunction}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ecutrho}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+m+mi}{45}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} Cutoff for the density}
        \PYG{c+c1}{\PYGZsh{} Information about smearing (it is a metal)}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{occupations}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smearing}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smearing}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{degauss}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+m+mf}{0.03}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{electrons}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{conv\PYGZus{}thr}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}8}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} the pseudopotential for each chemical element}
\PYG{c+c1}{\PYGZsh{} In this case just Gold}
\PYG{n}{pseudopotentials} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Au}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Au\PYGZus{}ONCV\PYGZus{}PBE\PYGZhy{}1.0.oncvpsp.upf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} the kpoints mesh and the offset}
\PYG{n}{kpts} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{koffset} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Prepare the quantum espresso calculator}
\PYG{n}{calculator} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{calculators}\PYG{o}{.}\PYG{n}{Espresso}\PYG{p}{(}\PYG{n}{input\PYGZus{}data}\PYG{p}{,}
                                     \PYG{n}{pseudopotentials}\PYG{p}{,}
                                     \PYG{n}{kpts} \PYG{o}{=} \PYG{n}{kpts}\PYG{p}{,}
                                     \PYG{n}{koffset} \PYG{o}{=} \PYG{n}{koffset}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you are familiar with the quantum espresso input files, you should recognize all the options inside the input\_data dictionary. For more options and more information, refer to the \sphinxhref{https://www.quantum-espresso.org/Doc/INPUT\_PW.html}{quantum ESPRESSO pw.x input guide}.

\sphinxAtStartPar
Remember, the parameters setted here are just for fun, remember to run appropriate convergence check of the kmesh, smearing and basis set cutoffs before running the SSCHA code.
Keep also in mind that this input file refers to the supercell, and the kpts variable can be properly rescaled if the supercell is increased.

\sphinxAtStartPar
All the rest of the code remains the same (but here we do not compute harmonic phonons, which can be done more efficiently within the Quantum ESPRESSO).
Instead, we take the result obtained with EMT in the previous sections, and try to relax the free energy with a fully ab\sphinxhyphen{}initio approach.

\sphinxAtStartPar
The complete code is inside Examples/sscha\_and\_dft/nvt\_local.py

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import the sscha code}
\PYG{k+kn}{import} \PYG{n+nn}{sscha}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Ensemble}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{SchaMinimizer}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Relax}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Utilities}

\PYG{c+c1}{\PYGZsh{} Import the cellconstructor library to manage phonons}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor} \PYG{k}{as} \PYG{n+nn}{CC}\PYG{o}{,} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{Phonons}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{Structure}\PYG{o}{,} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{calculators}

\PYG{c+c1}{\PYGZsh{} Import the DFT calculator}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{calculators}

\PYG{c+c1}{\PYGZsh{} Import numerical and general pourpouse libraries}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}\PYG{o}{,} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{sys}\PYG{o}{,} \PYG{n+nn}{os}


\PYG{c+c1}{\PYGZsh{} Initialize the DFT (Quantum Espresso) calculator for gold}
\PYG{c+c1}{\PYGZsh{} The input data is a dictionary that encodes the pw.x input file namelist}
\PYG{n}{input\PYGZus{}data} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{control}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{\PYGZsh{} Avoid writing wavefunctions on the disk}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{disk\PYGZus{}io}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{None}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{c+c1}{\PYGZsh{} Where to find the pseudopotential}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pseudo\PYGZus{}dir}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{system}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{\PYGZsh{} Specify the basis set cutoffs}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ecutwfc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+m+mi}{45}\PYG{p}{,}   \PYG{c+c1}{\PYGZsh{} Cutoff for wavefunction}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ecutrho}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+m+mi}{45}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} Cutoff for the density}
        \PYG{c+c1}{\PYGZsh{} Information about smearing (it is a metal)}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{occupations}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smearing}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smearing}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{degauss}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+m+mf}{0.03}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{electrons}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{conv\PYGZus{}thr}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}8}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} the pseudopotential for each chemical element}
\PYG{c+c1}{\PYGZsh{} In this case just Gold}
\PYG{n}{pseudopotentials} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Au}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Au\PYGZus{}ONCV\PYGZus{}PBE\PYGZhy{}1.0.oncvpsp.upf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} the kpoints mesh and the offset}
\PYG{n}{kpts} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{koffset} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Specify the command to call quantum espresso}
\PYG{n}{command} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pw.x \PYGZhy{}i PREFIX.pwi \PYGZgt{} PREFIX.pwo}\PYG{l+s+s1}{\PYGZsq{}}


\PYG{c+c1}{\PYGZsh{} Prepare the quantum espresso calculator}
\PYG{n}{calculator} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{calculators}\PYG{o}{.}\PYG{n}{Espresso}\PYG{p}{(}\PYG{n}{input\PYGZus{}data}\PYG{p}{,}
                                     \PYG{n}{pseudopotentials}\PYG{p}{,}
                                     \PYG{n}{command} \PYG{o}{=} \PYG{n}{command}\PYG{p}{,}
                                     \PYG{n}{kpts} \PYG{o}{=} \PYG{n}{kpts}\PYG{p}{,}
                                     \PYG{n}{koffset} \PYG{o}{=} \PYG{n}{koffset}\PYG{p}{)}



\PYG{n}{TEMPERATURE} \PYG{o}{=} \PYG{l+m+mi}{300}
\PYG{n}{N\PYGZus{}CONFIGS} \PYG{o}{=} \PYG{l+m+mi}{50}
\PYG{n}{MAX\PYGZus{}ITERATIONS} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{START\PYGZus{}DYN} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{start\PYGZus{}dyn}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{NQIRR} \PYG{o}{=} \PYG{l+m+mi}{13}

\PYG{c+c1}{\PYGZsh{} Let us load the starting dynamical matrix}
\PYG{n}{gold\PYGZus{}dyn} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Phonons}\PYG{o}{.}\PYG{n}{Phonons}\PYG{p}{(}\PYG{n}{START\PYGZus{}DYN}\PYG{p}{,} \PYG{n}{NQIRR}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the random ionic ensemble}
\PYG{n}{ensemble} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{p}{(}\PYG{n}{gold\PYGZus{}dyn}\PYG{p}{,} \PYG{n}{TEMPERATURE}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the free energy minimizer}
\PYG{n}{minim} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{SchaMinimizer}\PYG{o}{.}\PYG{n}{SSCHA\PYGZus{}Minimizer}\PYG{p}{(}\PYG{n}{ensemble}\PYG{p}{)}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{set\PYGZus{}minimization\PYGZus{}step}\PYG{p}{(}\PYG{l+m+mf}{0.01}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the NVT simulation}
\PYG{n}{relax} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Relax}\PYG{o}{.}\PYG{n}{SSCHA}\PYG{p}{(}\PYG{n}{minim}\PYG{p}{,} \PYG{n}{calculator}\PYG{p}{,} \PYG{n}{N\PYGZus{}configs} \PYG{o}{=} \PYG{n}{N\PYGZus{}CONFIGS}\PYG{p}{,}
                          \PYG{n}{max\PYGZus{}pop} \PYG{o}{=} \PYG{n}{MAX\PYGZus{}ITERATIONS}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define the I/O operations}
\PYG{c+c1}{\PYGZsh{} To save info about the free energy minimization after each step}
\PYG{n}{ioinfo} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Utilities}\PYG{o}{.}\PYG{n}{IOInfo}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ioinfo}\PYG{o}{.}\PYG{n}{SetupSaving}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{minim\PYGZus{}info}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{setup\PYGZus{}custom\PYGZus{}functions}\PYG{p}{(}\PYG{n}{custom\PYGZus{}function\PYGZus{}post} \PYG{o}{=} \PYG{n}{ioinfo}\PYG{o}{.}\PYG{n}{CFP\PYGZus{}SaveAll}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Run the NVT simulation (save the stress to compute the pressure)}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{relax}\PYG{p}{(}\PYG{n}{get\PYGZus{}stress} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} If instead you want to run a NPT simulation, use}
\PYG{c+c1}{\PYGZsh{} The target pressure is given in GPa.}
\PYG{c+c1}{\PYGZsh{}relax.vc\PYGZus{}relax(target\PYGZus{}press = 0)}

\PYG{c+c1}{\PYGZsh{} You can also run a mixed simulation (NVT) but with variable lattice parameters}
\PYG{c+c1}{\PYGZsh{}relax.vc\PYGZus{}relax(fix\PYGZus{}volume = True)}

\PYG{c+c1}{\PYGZsh{} Now we can save the final dynamical matrix}
\PYG{c+c1}{\PYGZsh{} And print in stdout the info about the minimization}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{minim}\PYG{o}{.}\PYG{n}{finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{minim}\PYG{o}{.}\PYG{n}{dyn}\PYG{o}{.}\PYG{n}{save\PYGZus{}qe}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sscha\PYGZus{}T}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZus{}dyn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{TEMPERATURE}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now you can run the SSCHA with an ab\sphinxhyphen{}initio code!
However, your calculation will probably take forever.
To speedup things, lets discuss parallelization and how to exploit modern HPC infrastructures.


\section{Parallelization}
\label{\detokenize{start:parallelization}}
\sphinxAtStartPar
If you actually tried to run the code of the previous section on a laptop, it will take forever.
The reason is that DFT calculations are much more expensive than the SSCHA minimization. While SSCHA minimizes the number of ab initio calculations (especially when compared with MD or PIMD), still they are the bottleneck of the computational time.

\sphinxAtStartPar
For this reason, we need an opportune parallelization strategy to reduce the total time to run a SSCHA.

\sphinxAtStartPar
The simplest way is to call the previous python script with MPI:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} mpirun \PYGZhy{}np \PYG{l+m}{50} python nvt\PYGZus{}local.py \PYGZgt{} output.log
\end{sphinxVerbatim}

\sphinxAtStartPar
The code will split the configurations in each ensemble on a different MPI process. In this case we have 50 configurations per ensemble, by splitting them into 50 processors, we run the full ensemble in parallel.

\sphinxAtStartPar
However, still the single DFT calculation on 1 processor is going to take hours, and in some cases it may even take days.
Luckily, also quantum ESPRESSO (and many other software) have an internal parallelization to work with.
For example, we can tell quantum espresso to run itself in parallel on 8 processors.
To this purpouse, we simply need to modify the command used to run quantum espresso in the previous script.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Lets replace}
\PYG{c+c1}{\PYGZsh{} command = \PYGZsq{}pw.x \PYGZhy{}i PREFIX.pwi \PYGZgt{} PREFIX.pwo\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} with}
\PYG{n}{command} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mpirun \PYGZhy{}np 8 pw.x \PYGZhy{}npool 1 \PYGZhy{}i PREFIX.pwi \PYGZgt{} PREFIX.pwo}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} The command string is passed to the espresso calculator}
\PYG{n}{calculator} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{calculators}\PYG{o}{.}\PYG{n}{Espresso}\PYG{p}{(}\PYG{n}{input\PYGZus{}data}\PYG{p}{,}
                                     \PYG{n}{pseudopotentials}\PYG{p}{,}
                                     \PYG{n}{command} \PYG{o}{=} \PYG{n}{command}\PYG{p}{,}
                                     \PYG{n}{kpts} \PYG{o}{=} \PYG{n}{kpts}\PYG{p}{,}
                                     \PYG{n}{koffset} \PYG{o}{=} \PYG{n}{koffset}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this way, our calculations will run on 400 processors (50 processors splits the ensemble times 8 processors per each calculation).
This is achieved by nesting mpi calls. However, only the cellconstructor calculators can nest mpi calls without raising errors. This is the reason why we imported the Espresso class from cellconstructor and not from ASE.
If you want to use ASE for your calculator, you can only use the inner parallelization of the calculator modifying the command, as ASE itself implements a MPI parallelization on I/O operations that conflicts with the python\sphinxhyphen{}sscha parallelization. This limitation only applies to FileIOCalculators from ASE (thus the EMT force\sphinxhyphen{}field is not affected and can be safely employed with python\sphinxhyphen{}sscha parallelization).

\sphinxAtStartPar
With this setup, the full code is parallelized over 400 processors. However the SSCHA minimization algorithm is a serial one, and all the time spent in the actual SSCHA minimization is wasting the great number of resources allocated.
Moreover, the SSCHA code needs to be configured and correctly installed on the cluster, which may be a difficult operation due to the hybrid Fortran/pyhton structure.

\sphinxAtStartPar
In the next section, we provide a workaround: Running the SSCHA code on your laptop, and configure it to automatically interact with a remote server (HPC) in which the ensemble calculation is submitted.
This is the best way to use the python\sphinxhyphen{}sscha code, as no installation of the code in the cluster is required, and the time spent during the minimization does not occupy precious HPC resources.


\section{Remote submission on a queue system}
\label{\detokenize{start:remote-submission-on-a-queue-system}}
\sphinxAtStartPar
To configure SSCHA to work with a cluster we need to tell the code some info to ssh into it.
Here is a basic configuration to connect to the Piz Daint cluster at CSCS (Switzerland), but it is very similar to any other cluster.

\sphinxAtStartPar
First of all, we need to configure a straight ssh connection. We have to add to the configuration file of ssh the information about Host and Username. In my case, the \$HOME/.ssh/config file looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Host ela
     HostName ela.cscs.ch
     User lmonacel
Host daint
     HostName daint.cscs.ch
     ProxyJump ela
     User lmonacel
\end{sphinxVerbatim}

\sphinxAtStartPar
These are two connection, one to ela (the front\sphinxhyphen{}end server of CSCS) and then one to daint.
To connect to daint, I must before access to ela, this is the reason of ProxyJump command inside the daint block.
The best way to connect is to configure your ssh private\sphinxhyphen{}public key so that you (and python\sphinxhyphen{}sscha) can login without password.
An example of how to do that is \sphinxhref{http://www.linuxproblem.org/art\_9.html}{Here}, but you may find a lot of other on internet.

\sphinxAtStartPar
Sometimes cluster may not allow passwordless connection, in this case, you need to provide the password explicitly to python\sphinxhyphen{}sscha.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Let us define the cluster}
\PYG{k+kn}{import} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Cluster}
\PYG{n}{cluster} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Cluster}\PYG{o}{.}\PYG{n}{Cluster}\PYG{p}{(}\PYG{n}{hostname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{daint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pwd} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Put the password in pwd if needed}

\PYG{c+c1}{\PYGZsh{} Configure the submission strategy}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{account\PYGZus{}name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s1073}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} Name of the account on which to subtract nodes}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{n\PYGZus{}nodes} \PYG{o}{=} \PYG{l+m+mi}{1}             \PYG{c+c1}{\PYGZsh{} Number of nodes requested for each job}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{time} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{02:30:00}\PYG{l+s+s1}{\PYGZsq{}}       \PYG{c+c1}{\PYGZsh{} Total time requested for each job}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{n\PYGZus{}pool} \PYG{o}{=} \PYG{l+m+mi}{1}              \PYG{c+c1}{\PYGZsh{} Number of pools for the Quantum ESPRESSO calculation}

\PYG{c+c1}{\PYGZsh{} Here some custom parameters for the clusters}
\PYG{c+c1}{\PYGZsh{} These are specific for daint, but you can easily figure out those for your machine}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{custom\PYGZus{}params}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}constraint}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gpu}\PYG{l+s+s2}{\PYGZdq{}}      \PYG{c+c1}{\PYGZsh{} Run on the GPU partition}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{custom\PYGZus{}params}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}ntasks\PYGZhy{}per\PYGZhy{}node}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{custom\PYGZus{}params}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}cpus\PYGZhy{}per\PYGZhy{}task}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Since daint specify the partition with a custom option,}
\PYG{c+c1}{\PYGZsh{} Lets remove the specific partition option of SLURM}
\PYG{c+c1}{\PYGZsh{} Neither we want to specify the total number of cpus (automatically determined by the node)}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{use\PYGZus{}partition} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{use\PYGZus{}cpu} \PYG{o}{=} \PYG{k+kc}{False}


\PYG{c+c1}{\PYGZsh{} Now, we need to tell daint which modules to load to run quantum espresso}
\PYG{c+c1}{\PYGZsh{} Also this is cluster specific, but very simple to figure it out for you}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{load\PYGZus{}modules} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{\PYGZsh{} Load the quantum espresso modules}
\PYG{l+s+s2}{module load daint\PYGZhy{}gpu}
\PYG{l+s+s2}{module load QuantumESPRESSO}

\PYG{l+s+s2}{\PYGZsh{} Configure the environmental variables of the job}
\PYG{l+s+s2}{export OMP\PYGZus{}NUM\PYGZus{}THREADS=\PYGZdl{}}\PYG{l+s+si}{\PYGZob{}SLURM\PYGZus{}CPUS\PYGZus{}PER\PYGZus{}TASK\PYGZcb{}}
\PYG{l+s+s2}{export NO\PYGZus{}STOP\PYGZus{}MESSAGE=1}
\PYG{l+s+s2}{export CRAY\PYGZus{}CUDA\PYGZus{}MPS=1}

\PYG{l+s+s2}{ulimit \PYGZhy{}s unlimited}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Now, what is the command to run quantum espresso on the cluster?}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{binary} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pw.x \PYGZhy{}npool NPOOL \PYGZhy{}i PREFIX.pwi \PYGZgt{} PREFIX.pwo}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} NOTE that NPOOL will be replaced automatically with the cluster.n\PYGZus{}pool variable}


\PYG{c+c1}{\PYGZsh{} Let us setup the working directory (directory in which the jobs runs)}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{workdir} \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}SCRATCH/Gold\PYGZus{}NVT\PYGZus{}300k}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{setup\PYGZus{}workdir}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Login to the cluster and creates the working directory if it does not exist}


\PYG{c+c1}{\PYGZsh{} Last but not least:}
\PYG{c+c1}{\PYGZsh{}  How many jobs do you want to submit simultaneously?}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{10}

\PYG{c+c1}{\PYGZsh{}  Now many DFT calculation do you want to run inside each job?}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{job\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\sphinxAtStartPar
And here we go. We configured the connection to daint. It may seem a bit complex, however, all the configuration is a simple interface to SLURM, and we are only passing informations that are going into the \#SBATCH syntax.

\sphinxAtStartPar
Once you defined the cluster, you can run the calculation providing the cluster object to the sscha.Relax.SSCHA class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Initialize the simulation}
\PYG{n}{relax} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Relax}\PYG{o}{.}\PYG{n}{SSCHA}\PYG{p}{(}\PYG{n}{minim}\PYG{p}{,} \PYG{n}{calculator}\PYG{p}{,}
             \PYG{n}{N\PYGZus{}configs} \PYG{o}{=} \PYG{n}{N\PYGZus{}CONFIGS}\PYG{p}{,}
             \PYG{n}{max\PYGZus{}pop} \PYG{o}{=} \PYG{n}{MAX\PYGZus{}ITERATIONS}\PYG{p}{,}
             \PYG{n}{cluster} \PYG{o}{=} \PYG{n}{cluster}\PYG{p}{,}
             \PYG{n}{save\PYGZus{}ensemble} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
And that’s it. Instead of running espresso locally, python\sphinxhyphen{}sscha submit the calculations on the specified cluster.
Here we also added the save\_ensemble flag equal to true. Since DFT calculation are computationally expensive, we may want to save the results of each ensemble for further analysis (as computing linear response properties), or maybe to train a neural\sphinxhyphen{}network potential later.

\sphinxAtStartPar
By default, the ensemble is stored into a directory called ‘data’. You can change it to what you want by editing the setting

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{relax}\PYG{o}{.}\PYG{n}{data\PYGZus{}dir} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my\PYGZus{}new\PYGZus{}data}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the directory does not exist, python\sphinxhyphen{}sscha creates it automatically.
While the cluster configuration may seem a bit more complex, it is the best way to go.


\section{Other tutorials}
\label{\detokenize{start:other-tutorials}}
\sphinxAtStartPar
Congratulations. If you arrived here, it means that you now have a good overview of the basic functionalities of the SSCHA code, as running an NVT and NPT simulations.

\sphinxAtStartPar
We provide some other tutorial to help you to get used to some other advanced properties, like linear response (Hessian matrix) and spectral properties.

\sphinxAtStartPar
You find these tutorials as executable jupyter notebooks in the Tutorial folder, or in the static html version on the sscha website: \sphinxhref{http://sscha.eu/tutorials/}{www.sscha.eu/tutorials}

\sphinxAtStartPar
Tutorials are organized as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Setup from the structure and manual submission: PbTe tutorial. Here you learn how to set up a SSCHA calculation starting just with the structure (we provide a .cif file of the PbTe at high temperature). The tutorial will guide you step by step. You will learn how to: prepare the starting data needed for the SSCHA calculation, generate a random ensemble, save the ensemble and prepare input files for your favorite ab\sphinxhyphen{}initio code, read back the energies and the forces inside SSCHA, run a SSCHA minimization. You will also learn how to use ASE and the Cluster module to automatize the calculation of the ensemble and submit it to a HPC system.

\item {} 
\sphinxAtStartPar
Automatic relaxation with a force field: SnTe\_ToyModel. Here, we show how to use a force\sphinxhyphen{}field for a SSCHA calculation, running everything on your computer. We also will explain how to calculate the free energy hessian for second\sphinxhyphen{}order phase transitions, and study a phase transition as a function of temperature.

\item {} 
\sphinxAtStartPar
Variable cell relaxation: LaH10 tutorial. Here you learn how to perform an automatic calculation with a variable cell. You will exploit the quantum effect to search the high\sphinxhyphen{}temperature superconductive phase (Fm\sphinxhyphen{}3m) of LaH10 below 200 GPa, starting from a distorted structure.

\item {} 
\sphinxAtStartPar
Hessian matrix calculation for second\sphinxhyphen{}order phase transitions: H3S tutorial. Here you reproduce the calculation of the Hessian of the free energy to assert the stability of the H3S phase.

\item {} 
\sphinxAtStartPar
Spectral properties: Spectral\_Properties. In this tutorial, we explain how to use the post\sphinxhyphen{}processing utilities of the SSCHA to calculate the phonon spectral function, and computing phonon lifetimes, and plotting interacting phonon dispersion. We provide an ensemble for PbTe already computed ab\sphinxhyphen{}initio.

\end{enumerate}

\sphinxAtStartPar
The jupyter notebooks are interactive, to quickly start with your simulation, pick the tutorial that resembles the kind of calculation you want to run, and simply edit it directly in the notebook.

\sphinxstepscope


\chapter{Advanced Features}
\label{\detokenize{advanced:advanced-features}}\label{\detokenize{advanced::doc}}
\sphinxAtStartPar
The python\sphinxhyphen{}sscha code can be runned both as a stand\sphinxhyphen{}alone application with an input file and as a python library, writing a python script.

\sphinxAtStartPar
We will cover the python scripting as it is more general.
\begin{description}
\sphinxlineitem{The SSCHA calculation is divided into 3 main steps:}\begin{itemize}
\item {} 
\sphinxAtStartPar
The generation of a random ensemble of ionic configurations

\item {} 
\sphinxAtStartPar
Calculations of energies and forces on the ensemble

\item {} 
\sphinxAtStartPar
The SSCHA free energy minimization

\end{itemize}

\end{description}

\sphinxAtStartPar
Then this steps are iterated until convergence is achieved.

\sphinxAtStartPar
In this chapter, we cover some advanced features of the SSCHA code, as the manual submission, the use of constrains on modes and atoms or the configurations of cluster with a DFT code different from quantum ESPRESSO.


\section{Manual submission}
\label{\detokenize{advanced:manual-submission}}
\sphinxAtStartPar
The manual submission allows the user to take full controll over any steps in the simulation. It also means that the code perform just one iteration, and the user must interact with it to provide the forces and energies of the ensemble at each iterations.

\sphinxAtStartPar
It is usefull if you want to have full control on the number of configurations required to converge, or if you simply do not want to configure the automatic submission through a cluster because you have limited resources and are scared that the code could burn too much computer time without you realizing.

\sphinxAtStartPar
Indeed, it is strongly discuraged in variable cell simulations, as the code exploits the results from previous iterations to optimize the cell in a clever way.

\sphinxAtStartPar
The manual submission means that the user manually computes the energies and forces of all the configurations in the ensemble. The code stops after generating the random ensemble, and the user is requested to provide data files that contain the forces and total energies for each configuration.

\sphinxAtStartPar
Thus, the code works in two steps.
In the first step we generate the ensemble. Here is the code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sscha}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Ensemble}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{SchaMinimizer}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor} \PYG{k}{as} \PYG{n+nn}{CC}\PYG{o}{,} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{Phonons}

\PYG{c+c1}{\PYGZsh{} Load the harmonic dynamical matrix}
\PYG{n}{dyn} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Phonons}\PYG{o}{.}\PYG{n}{Phonons}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dyn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{nqirr} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} If the dynamical matrix contains imaginary frequencies}
\PYG{c+c1}{\PYGZsh{} we get rid of them with}
\PYG{n}{dyn}\PYG{o}{.}\PYG{n}{ForcePositiveDefinite}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Now we initialize the ensemble at the target temperature}
\PYG{n}{TEMPERATURE} \PYG{o}{=} \PYG{l+m+mi}{300} \PYG{c+c1}{\PYGZsh{} Kelvin}
\PYG{n}{ensemble} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{p}{(}\PYG{n}{dyn}\PYG{p}{,} \PYG{n}{TEMPERATURE}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} We generate the random ensemble with N\PYGZus{}CONFIGS configurations}
\PYG{n}{N\PYGZus{}CONFIGS} \PYG{o}{=} \PYG{l+m+mi}{1000}
\PYG{n}{ensemble}\PYG{o}{.}\PYG{n}{generate}\PYG{p}{(}\PYG{n}{N\PYGZus{}CONFIGS}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} We save the ensemble on the disk (inside directory data)}
\PYG{c+c1}{\PYGZsh{} We specify an integer \PYGZsq{}population\PYGZsq{} which distinguish several ensembles}
\PYG{c+c1}{\PYGZsh{} inside the same directory}
\PYG{n}{ensemble}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{population} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To start, we need an initial guess of the dynamical matrix (the dyn file).
The default format is the one of Quantum ESPRESSO, but also phonopy and
ASE formats are supported (refer to the CellConstructor documentation to load these formats). Here we assume that the dynamical matrices are 4 (4 irreducible q points) called ‘dyn1’, ‘dyn2’, ‘dyn3’ and ‘dyn4’, as the standard quantum espresso format.

\sphinxAtStartPar
The dynamical matrix contain both the information about the atomic structure
and the ionic fluctuations. These can be obtained with a linear response
calculation from DFT.

\sphinxAtStartPar
The previous code generates the ensemble which is stored in the disk.
Inside the data directory you will find a lot of files

\sphinxAtStartPar
The files named ‘scf\_population1\_X.dat’ with X going over all the configurations contain the atomic structure in cartesian coordinates. It uses the standard espresso formalism.

\sphinxAtStartPar
You need to compute total energies and forces of each configuration, with your favourite code.
The total energies are written in column inside the file ‘total\_energies\_population1.dat’, in Rydberg atomic units and ordered with the index of the configurations.
The forces for each configuration should be inside ‘forces\_population1\_X.dat’ in Ry/Borh (Rydberg atomic units).

\sphinxAtStartPar
When you compute energies and forces, you can load them and run the SSCHA minimization:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sscha}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Ensemble}\PYG{o}{,} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{SchaMinimizer}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor} \PYG{k}{as} \PYG{n+nn}{CC}\PYG{o}{,} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{Phonons}

\PYG{c+c1}{\PYGZsh{} Load the harmonic dynamical matrix}
\PYG{n}{dyn} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Phonons}\PYG{o}{.}\PYG{n}{Phonons}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dyn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{nqirr} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} If the dynamical matrix contains imaginary frequencies}
\PYG{c+c1}{\PYGZsh{} we get rid of them with}
\PYG{n}{dyn}\PYG{o}{.}\PYG{n}{ForcePositiveDefinite}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Now we initialize the ensemble at the target temperature}
\PYG{n}{TEMPERATURE} \PYG{o}{=} \PYG{l+m+mi}{300} \PYG{c+c1}{\PYGZsh{} Kelvin}
\PYG{n}{ensemble} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{p}{(}\PYG{n}{dyn}\PYG{p}{,} \PYG{n}{TEMPERATURE}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} We load the ensemble}
\PYG{n}{N\PYGZus{}CONFIGS} \PYG{o}{=} \PYG{l+m+mi}{1000}
\PYG{n}{ensemble}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{population} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{N} \PYG{o}{=} \PYG{n}{N\PYGZus{}CONFIGS}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Now we can run the sscha minimization}
\PYG{n}{minim} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{SchaMinimizer}\PYG{o}{.}\PYG{n}{SSCHA\PYGZus{}Minimizer}\PYG{p}{(}\PYG{n}{ensemble}\PYG{p}{)}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Print on stdout the final results}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{finalize}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save the output dynamical matrix}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{dyn}\PYG{o}{.}\PYG{n}{save\PYGZus{}qe}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{final\PYGZus{}dyn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
And that’s it. You run your first manual calculation.


\section{Keep track of free energy, gradients and frequencies during minimization}
\label{\detokenize{advanced:keep-track-of-free-energy-gradients-and-frequencies-during-minimization}}
\sphinxAtStartPar
It is convenient to store on the file the information during the minimization, as the Free Energy, its gradient values and the frequencies.

\sphinxAtStartPar
To do this, we need to tell the code to save them into a file.

\sphinxAtStartPar
Let us replace the ‘minim.run()’ line in the previous example with the following code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sscha}\PYG{n+nn}{.}\PYG{n+nn}{Utilities}
\PYG{n}{IO} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Utilities}\PYG{o}{.}\PYG{n}{IOinfo}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{IO}\PYG{o}{.}\PYG{n}{SetupSaving}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{minim\PYGZus{}data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{minim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{custom\PYGZus{}function\PYGZus{}post} \PYG{o}{=} \PYG{n}{IO}\PYG{o}{.}\PYG{n}{CFP\PYGZus{}SaveAll}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you run it again, the code produces (starting from verison 1.2) two data files: minim\_data.dat and minim\_data.freqs.
You can plot all the minimization path (frequencies, free energy, gradients) calling the program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sscha\PYGZhy{}plot\PYGZhy{}data.py minim\PYGZus{}data
\end{sphinxVerbatim}

\sphinxAtStartPar
The sscha\sphinxhyphen{}plot\sphinxhyphen{}data.py script is automatically installed within the SSCHA code.


\section{Cluster configuration with a code different from Quantum ESPRESSO}
\label{\detokenize{advanced:cluster-configuration-with-a-code-different-from-quantum-espresso}}
\sphinxAtStartPar
TODO


\section{Employ a custom function}
\label{\detokenize{advanced:employ-a-custom-function}}
\sphinxAtStartPar
An interesting feature provided by the SSCHA code is the customization of the algorithm. The user has access to all the variables at each iteration of the minimization.
In this way, the user can print on files additional info or introduce constraints on the structure or on the dynamical matrix.
The interaction between the user and the SSCHA minimization occurs through three functions, that are defined by the user and passed to the \sphinxstylestrong{run} method of the \sphinxstylestrong{SSCHA\_Minimizer} class (in the \sphinxstylestrong{SchaMinimizer} module):
\begin{itemize}
\item {} 
\sphinxAtStartPar
custom\_function\_pre

\item {} 
\sphinxAtStartPar
custom\_function\_gradient

\item {} 
\sphinxAtStartPar
custom\_function\_post

\end{itemize}

\sphinxAtStartPar
These functions are called by the code before, during, and after each iteration.

\sphinxAtStartPar
The \sphinxstylestrong{Utilities} module already provides some basic functions, that can be used for standard purpouses.
For example, the following code employs \sphinxstyleemphasis{custom\_function\_post} to print on a file the auxiliary dynamical matrix’s frequencies at each step.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{IO} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Utilities}\PYG{o}{.}\PYG{n}{IOinfo}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{IO}\PYG{o}{.}\PYG{n}{SetupSaving}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{freqs.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} .... initialize minim as SSCHA\PYGZus{}Minimizer class}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(} \PYG{n}{custom\PYGZus{}function\PYGZus{}post} \PYG{o}{=} \PYG{n}{IO}\PYG{o}{.}\PYG{n}{CFP\PYGZus{}SaveAll}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case \sphinxstyleemphasis{IO.CFP\_SaveAll} is the \sphinxstyleemphasis{custom\_function\_post}. It is a standard python method, that takes one argument (the SSCHA\_Minimizer).
\sphinxstyleemphasis{IO.CFP\_SaveAll}  prints the frequencies of the current dynamical matrix (stored in minim.dyn) in the filename defined by \sphinxstyleemphasis{IO.SetupSaving(“freqs.dat”)}.

\sphinxAtStartPar
The following example, we define a \sphinxstyleemphasis{custom\_function\_post} not provided by the Utilities module. The following code generate a file with the full dynamical matrix for each iteration of the minimization algorithm.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}dyn}\PYG{p}{(}\PYG{n}{current\PYGZus{}minim}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Get the current step id checking the lenght of the \PYGZus{}\PYGZus{}fe\PYGZus{}\PYGZus{} variable (the free energy)}
        \PYG{n}{step\PYGZus{}id} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{current\PYGZus{}minim}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}fe\PYGZus{}\PYGZus{}}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Save the dynamical matrix}
        \PYG{n}{minim}\PYG{o}{.}\PYG{n}{dyn}\PYG{o}{.}\PYG{n}{save\PYGZus{}qe}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dyn\PYGZus{}at\PYGZus{}step\PYGZus{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{step\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, \sphinxstyleemphasis{print\_dyn} is the \sphinxstyleemphasis{custom\_function\_post}. We must pass it to the \sphinxstyleemphasis{run} method of the \sphinxstyleemphasis{SSCHA\_Minimizer} class (minim in the following case).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{custom\PYGZus{}function\PYGZus{}post} \PYG{o}{=} \PYG{n}{print\PYGZus{}dyn}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this way, you can interact with the code, getting access to all the variables of the minimization after each step. This could be exploited, for example, to print atomic positions, bond lenght distances or angles during the minimization, or to setup a live self\sphinxhyphen{}updating plot of the free energy and its gradient, that automatically refreshes at each step.


\section{Constraints}
\label{\detokenize{advanced:constraints}}
\sphinxAtStartPar
Another important case in which you want to interact with the code is to constrain the minimization.
A standard constraint is the locking of modes, in which you only optimize a subset of phonon branches defined from the beginning. Let us have a look at the code to constrain the modes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} [...] Load the initial dynamical matrix as dyn}
\PYG{n}{ModeLock} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Utilities}\PYG{o}{.}\PYG{n}{ModeProjection}\PYG{p}{(}\PYG{n}{dyn}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Setup the constrain on phonon branches from 4 to 8 (ascending energy)}
\PYG{n}{ModeLock}\PYG{o}{.}\PYG{n}{SetupFreeModes}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} [...] Define the SSCHA\PYGZus{}Minimizer as minim}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{custom\PYGZus{}function\PYGZus{}gradient} \PYG{o}{=} \PYG{n}{ModeLock}\PYG{o}{.}\PYG{n}{CFG\PYGZus{}ProjectOnModes}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function \sphinxstyleemphasis{ModeLock.CFG\_ProjectOnModes} is the \sphinxstyleemphasis{custom\_function\_gradient}. It takes two numpy array as input: the gradient of the dynamical matrix and the gradient on the structure.
Since numpy array are pointers to memory allocations, the content of the array can be modified by the function.
The \sphinxstyleemphasis{SSCHA\_Minimizer} calls \sphinxstyleemphasis{custom\_function\_gradient} immediately before emplying the gradient to generate the dyanmical matrix and the structure for the next iteration.
Therefore, \sphinxstyleemphasis{custom\_function\_gradient} is employed to apply costraints, projecting the gradients in the desidered subspace.

\sphinxAtStartPar
In particular, \sphinxstyleemphasis{CFG\_ProjectOnModes} projects the gradient of the dynamical matrix into the subspace defined only by the mode branches selected with \sphinxstyleemphasis{ModeLock.SetupFreeModes}. As done for \sphinxstyleemphasis{custom\_function\_post}, also here we can define a custom function instead of using the predefined one provided by the \sphinxstyleemphasis{Utilities} module.

\sphinxAtStartPar
The following code limit the projection on the subspace of modes only on the fourth q\sphinxhyphen{}point of the dynamical matrix.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{iq} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}constrain}\PYG{p}{(}\PYG{n}{dyn\PYGZus{}gradient}\PYG{p}{,} \PYG{n}{structure\PYGZus{}gradient}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Let us apply the standard constrain on modes}
        \PYG{n}{ModeLock}\PYG{o}{.}\PYG{n}{CFG\PYGZus{}ProjectOnModes}\PYG{p}{(}\PYG{n}{dyn\PYGZus{}gradient}\PYG{p}{,} \PYG{n}{structure\PYGZus{}gradient}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Now we set to zero the gradient of the dynamical matrix if it does not belong to the iq\PYGZhy{}th q point (ordered as they appear in the dynamical matrix used to initialize the minimization).}

        \PYG{n}{nq}\PYG{p}{,} \PYG{n}{nat3}\PYG{p}{,} \PYG{n}{nat3\PYGZus{}} \PYG{o}{=} \PYG{n}{dyn\PYGZus{}gradient}\PYG{o}{.}\PYG{n}{shape}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nq}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{iq}\PYG{p}{:}
                        \PYG{n}{dyn\PYGZus{}gradient}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}


\PYG{c+c1}{\PYGZsh{} [...] define minim as the SSCHA\PYGZus{}Minimizer}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{custom\PYGZus{}function\PYGZus{}gradient} \PYG{o}{=} \PYG{n}{my\PYGZus{}constrain}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The two arguments taken by custom\_function\_gradient are the gradient of the dynamical matrix of size (nq, 3*nat, 3*nat) and the gradient of the structure of size (nat, 3).
Notice also how, inside \sphinxstyleemphasis{my\_constrain}, we call \sphinxstyleemphasis{ModeLock.CFG\_ProjectOnModes}. You can concatenate many different custom functions following this approach.

\sphinxAtStartPar
Remember that the gradients are numpy arrays; \sphinxstylestrong{you must modify their content accessing their memory using the slices} {[}x,y,z{]} as we did.
In fact, if you overwrite the pointer to the memory (defining a new array), the content of the gradient will not be modified outside the function.
In the following code we show an example of correct and wrong.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This puts the gradient to zero}
\PYG{n}{dyn\PYGZus{}gradient}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}  \PYG{c+c1}{\PYGZsh{} CORRECT}

\PYG{c+c1}{\PYGZsh{} This does not put to zero the gradient}
\PYG{n}{dyn\PYGZus{}gradient} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(} \PYG{p}{(}\PYG{n}{nq}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{nat}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{nat}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} WRONG}
\end{sphinxVerbatim}

\sphinxAtStartPar
In particular, the second expression redefines the name \sphinxstyleemphasis{dyn\_gradient} only inside the function, allocating new memory on a different position, and overwriting the name \sphinxstyleemphasis{dyn\_gradient} only inside the function to point to this new memory location.  It \sphinxstylestrong{does not} write in the memory where \sphinxstyleemphasis{dyn\_gradient} is stored: the gradient outside the function is unchanged.

\sphinxAtStartPar
Indeed, you can also constrain the structure gradient. The ModeLocking class provides a function also to constrain the atomic displacement to follow the lattice vibrations identified by the selected branches at gamma.
This is \sphinxstyleemphasis{ModeLock.CFG\_ProjectStructure}. If you want to constrain both the dynamical matrix and the structure, you can simply concatenate them as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}constrain}\PYG{p}{(}\PYG{n}{dyn\PYGZus{}grad}\PYG{p}{,} \PYG{n}{structure\PYGZus{}grad}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ModeLock}\PYG{o}{.}\PYG{n}{CFG\PYGZus{}ProjectOnModes}\PYG{p}{(}\PYG{n}{dyn\PYGZus{}grad}\PYG{p}{,} \PYG{n}{structure\PYGZus{}grad}\PYG{p}{)}
        \PYG{n}{ModeLock}\PYG{o}{.}\PYG{n}{CFG\PYGZus{}ProjectStructure}\PYG{p}{(}\PYG{n}{dyn\PYGZus{}grad}\PYG{p}{,} \PYG{n}{structure\PYGZus{}grad}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} [...]}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{custom\PYGZus{}function\PYGZus{}gradient} \PYG{o}{=} \PYG{n}{my\PYGZus{}constrain}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Resuming, \sphinxstyleemphasis{custom functions} can be used to inject your personal code inside each SSCHA iteration. Proper use of this function gives you full control over the minimization and allows you to personalize the SSCHA without editing the source code.

\sphinxstepscope


\chapter{Frequently Asked Questions (FAQs)}
\label{\detokenize{faq:frequently-asked-questions-faqs}}\label{\detokenize{faq::doc}}
\sphinxAtStartPar
Here we answer to most common question we received.


\section{Setup the calculation}
\label{\detokenize{faq:setup-the-calculation}}

\subsection{How do I start a calculation if the Dynamical matrices have imaginary frequencies?}
\label{\detokenize{faq:how-do-i-start-a-calculation-if-the-dynamical-matrices-have-imaginary-frequencies}}
\sphinxAtStartPar
A good starting point for a sscha minimization are the dynamical matrix obtained from a harmonic calculation. However, they can have imaginary frequencies. This may be related to both instabilities (the structure is a saddle\sphinxhyphen{}point of the Born\sphinxhyphen{}Oppenheimer energy landscape) or to a not well\sphinxhyphen{}converged choice of the parameters for computing the harmonic frequencies.
In both cases, it is very easy to get a new dynamical matrix that is positive definite and can be used as a starting point. An example is made in Turorial on H3S.
Assuming your not positive definite dynamical matrix is in Quantum Espresso format “harm1” … “harmN” (with N the number of irreducible q points), you can generate a positive definite dynamical matrix “positive1” … “positiveN” with the following python script that uses CellConstructor.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Load the cellconstructor library}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor} \PYG{k}{as} \PYG{n+nn}{CC}
\PYG{k+kn}{import} \PYG{n+nn}{cellconstructor}\PYG{n+nn}{.}\PYG{n+nn}{Phonons}

\PYG{c+c1}{\PYGZsh{} Load the harmonic not\PYGZhy{}positive definite dynamical matrix}
\PYG{c+c1}{\PYGZsh{} We are reading 6 dynamical matrices}
\PYG{n}{harm} \PYG{o}{=} \PYG{n}{CC}\PYG{o}{.}\PYG{n}{Phonons}\PYG{o}{.}\PYG{n}{Phonons}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{harm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nqirr} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Apply the acoustic sum rule and the symmetries}
\PYG{n}{harm}\PYG{o}{.}\PYG{n}{Symmetrize}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Force the frequencies to be positive definite}
\PYG{n}{harm}\PYG{o}{.}\PYG{n}{ForcePositiveDefinite}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save the final dynamical matrix, ready to be used in a sscha run}
\PYG{n}{harm}\PYG{o}{.}\PYG{n}{save\PYGZus{}qe}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{positive}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The previous script (that we can save into \sphinxstyleemphasis{script.py}) will generate the positive definite matrix ready for the sscha run. It may be executed with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }python script.py
\end{sphinxVerbatim}


\subsection{What are the reasonable values for the steps?}
\label{\detokenize{faq:what-are-the-reasonable-values-for-the-steps}}
\sphinxAtStartPar
Starting from version 1.2, the line minimization is implemented. This means that there is no need to specify the value of the minimization step as the code will automatically find it.

\sphinxAtStartPar
However, if the code takes too long to get a good timestep at the begining of a calculation (especially at the very first iteration or if few configurations are employed), you could speedup the calculation providing a smaller initial guess than the default one (1).
This is done in the python script by calling the function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{set\PYGZus{}minimization\PYGZus{}step}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Where minim is the sscha.SchaMinimizer.SSCHA\_Minimizer class. You can select the step also in the namespace input by setting the following variables in the inputscha namespace

\sphinxAtStartPar
\sphinxstylestrong{lambda\_w} is the step in the atomic positions (stand\sphinxhyphen{}alone program input).

\sphinxAtStartPar
\sphinxstylestrong{lambda\_a} is the step in the dynamical matrix (stand\sphinxhyphen{}alone program input).


\subsection{In a NPT or NVT with variable lattice, what is a reasonable value for the bulk modulus?}
\label{\detokenize{faq:in-a-npt-or-nvt-with-variable-lattice-what-is-a-reasonable-value-for-the-bulk-modulus}}
\sphinxAtStartPar
The bulk modulus is just an indicative parameter used to guess the optimal step of the lattice parameters to converge as quickly as possible.
It is expressed in GPa. You can find online the bulk modulus for many materials. Find a material similar to the one you are studying and look if there is in literature a bulk modulus.

\sphinxAtStartPar
The default value is good for most case (equal to 100), but it could be too low for very hard materials (like diamond, which is 500 GPa, or high\sphinxhyphen{}pressure stuff). If you are not sure, it is safer to choose an higher value of the bulk modulus, as the code is going to optimize it during the simulation anyway.

\sphinxAtStartPar
If you have no idea on the bulk modulus, you can easily compute them by doing two static \sphinxstyleemphasis{ab initio} calculations at very close volumes (by varying the cell size), and then computing the differences between the pressure:
\begin{equation*}
\begin{split}B = - \Omega \frac{dP}{d\Omega}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Omega\) is the unit\sphinxhyphen{}cell volume and \(P\) is the pressure (in GPa).


\subsection{It is always good to run NVT before any NPT simulation?}
\label{\detokenize{faq:it-is-always-good-to-run-nvt-before-any-npt-simulation}}
\sphinxAtStartPar
In general, it is good to have a reasonable dynamical matrix before starting with a relaxation with variable cell (vc\_relax).
Therefore, to avoid mooving the volume upward and backward, always start with a NVT simulation with fixed lattice (the relax method of SSCHA class) and then run a NPT or a NVT with variable lattice (vc\_relax method), starting from the static lattice solution.


\subsection{How may I run a calculation neglecting symmetries?}
\label{\detokenize{faq:how-may-i-run-a-calculation-neglecting-symmetries}}
\sphinxAtStartPar
You can tell the code to neglect symmetries with the \sphinxcode{\sphinxupquote{neglect\_symmetries = .true.}} flag.
In the python script, this is done setting the attribute \sphinxstyleemphasis{neglect\_symmetries} of sscha.SchaMinimizer.SSCHA\_Minimizer to False.


\subsection{In which units are the lattice vectors, the atomic positions, and the mass of the atoms in the dynamical matrix file?}
\label{\detokenize{faq:in-which-units-are-the-lattice-vectors-the-atomic-positions-and-the-mass-of-the-atoms-in-the-dynamical-matrix-file}}
\sphinxAtStartPar
The dynamical matrix follows the quantum espresso units. They are Rydberg atomic units (unit of mass is 1/2  the electron mass, energy is Ry, positions are in Bohr. However, espresso may have an ibrav not equal to zero (the third number in the header of the dynamical matrix). In this case, please, refer to the espresso ibrav guide in the \sphinxtitleref{PW.x input description \textless{}https://www.quantum\sphinxhyphen{}espresso.org/Doc/INPUT\_PW.html\#idm199\textgreater{}}


\subsection{What is the difference between different kinds of minimization (preconditioning and root\_representation)?}
\label{\detokenize{faq:what-is-the-difference-between-different-kinds-of-minimization-preconditioning-and-root-representation}}
\sphinxAtStartPar
You do not need to worry about these parameters, as starting from version 1.2 the code has a robust workflow that should avoid bothering you with these details.
However, if you are curious and want to know a bit more on the details here it is the explanation:
We provide three different advanced algorithms called in \sphinxstylestrong{root\_representation}, that can be either \sphinxstylestrong{normal}, or \sphinxstylestrong{sqrt}, or \sphinxstylestrong{root4} (inside \&inputscha namespace or the SSCHA\_Minimizer object)
In this way, instead of minimizing the \(\Phi\) matrix, we minimize with respect to \(\sqrt{\Phi}\) or \(\sqrt[4]{\Phi}\).
Therefore the new dynamical matrix is constrained in a space that is positive definite. Moreover, it has been proved that \(\sqrt[4]{\Phi}\)
minimization has a better condition number than the original one and thus should reach the minimum faster.

\sphinxAtStartPar
Alternatively, a similar effect to the speedup in the minimization obtained with \sphinxstylestrong{root4} is possible using the preconditioning (by setting \sphinxstylestrong{preconditioning} or \sphinxstylestrong{precond\_dyn} to True in the input file or the python script, respectively). This way also the single minimization step runs faster, as it avoids passing in the root space of the dynamical matrix (but indeed, you can have imaginary frequencies).

\sphinxAtStartPar
Since the gradient computation is much slower (especially for a system with more than 80 atoms in the supercell) without the preconditioning,
it is possible to combine the preconditioning with the root representation to have a faster gradient computation and to be guaranteed that
the dynamical matrix is positive definite by construction at each step.
However, in this way the good condition number obtained by the preconditioning (or the root4 representation) is spoiled. For this reason, when using the preconditioning, avoid using \sphinxstylestrong{root4}, and chose instead \sphinxstylestrong{sqrt} as root\_representation.

\sphinxAtStartPar
The default values are:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}inputscha}
\PYG{g+go}{   root\PYGZus{}representation = \PYGZdq{}normal\PYGZdq{}}
\PYG{g+go}{   preconditioning = .true.}
\PYG{g+go}{\PYGZam{}end}
\end{sphinxVerbatim}

\sphinxAtStartPar
or in python

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} The ensemble has been loaded as ens}
\PYG{n}{minim} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{SchaMinimizer}\PYG{o}{.}\PYG{n}{SSCHA\PYGZus{}Minimizer}\PYG{p}{(}\PYG{n}{ens}\PYG{p}{)}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{root\PYGZus{}representation} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{normal}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{precond\PYGZus{}dyn} \PYG{o}{=} \PYG{k+kc}{True}
\end{sphinxVerbatim}


\subsection{How do I fix the random number generator seed to make a calculation reproducible?}
\label{\detokenize{faq:how-do-i-fix-the-random-number-generator-seed-to-make-a-calculation-reproducible}}
\sphinxAtStartPar
As for version 1.2, this can be achieved only by using the python script.
Since python uses NumPy for random numbers generation, you can, at the beginning of the script that generates the ensemble, use the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{X} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{n}{seed} \PYG{o}{=} \PYG{n}{X}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{X}} is the integer used as a seed. By default, if not specified, it is initialized with None that it is equivalent to initializing with the current local time.


\section{On error and convergence of the free energy minimization}
\label{\detokenize{faq:on-error-and-convergence-of-the-free-energy-minimization}}

\subsection{The code stops saying it has found imaginary frequencies, how do I fix it?}
\label{\detokenize{faq:the-code-stops-saying-it-has-found-imaginary-frequencies-how-do-i-fix-it}}
\sphinxAtStartPar
\sphinxstylestrong{Update python\sphinxhyphen{}sscha to version 1.2 (at least)!} This should be fixed.

\sphinxAtStartPar
If you do not want to update the code, set

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{root\PYGZus{}representation} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{root2}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This way the minimization strategy changes and it is mathematically impossible to get imaginary frequencies.
The same option can be activated within the namespace input

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZam{}inputscha}
\PYG{g+go}{   root\PYGZus{}representation = \PYGZsq{}root2\PYGZsq{}}
\PYG{g+go}{\PYGZam{}end}
\end{sphinxVerbatim}


\subsection{Why the gradient sometimes increases during a minimization?}
\label{\detokenize{faq:why-the-gradient-sometimes-increases-during-a-minimization}}
\sphinxAtStartPar
Noting in principle assures that a gradient should always go down. It is possible at the beginning of the calculation when we are far from the solution that one of the gradients increases.
However, when we get closer to the solution, indeed the gradient must decrease.
If this does not happen it could be due to the ensemble that has fewer configurations than necessary. In this case, the good choice is to increase the number of effective sample size (the Kong\sphinxhyphen{}Liu ratio), to stop the minimization when the gradient starts increasing, or to increase the number of configurations in the ensemble.

\sphinxAtStartPar
In any case, what must decrease is free energy. If you see that the gradient is increasing but the free energy decreases, then the minimization is correct. However, if both the gradient and free energy are increasing, something is wrong, and you may require more configurations in each iteration.
This is especially true for system with few symmetries (or big primitive cells).


\subsection{How do I check if my calculations are well converged?}
\label{\detokenize{faq:how-do-i-check-if-my-calculations-are-well-converged}}
\sphinxAtStartPar
In general, if the gradient goes to zero and the Kong Liu ratio is above 0.5 probably your calculation converged very well. This means that when your calculation stops because it converged (not because it runs out of iterations), then it should be well converged.

\sphinxAtStartPar
There are some cases (especially in systems with many atoms) in which it is difficult to have an ensemble sufficiently big to reach this condition.
In these cases, you can look at the history of the frequencies in the last populations (there is a drift or random fluctuations?)


\subsection{What is the final error on the structure or the dynamical matrix of a SCHA minimization?}
\label{\detokenize{faq:what-is-the-final-error-on-the-structure-or-the-dynamical-matrix-of-a-scha-minimization}}
\sphinxAtStartPar
To test the error, you can split the ensemble in two half and repeat the last minimization.
Then check at the difference between the result to have a rough estimation of the fluctuations.

\sphinxAtStartPar
To split the ensemble, refer to the FAQ {\hyperref[\detokenize{faq:faq-split}]{\sphinxcrossref{\DUrole{std,std-ref}{How do I split the ensemble?}}}}.


\subsection{How do I understand if the free energy hessian calculation is converged?}
\label{\detokenize{faq:how-do-i-understand-if-the-free-energy-hessian-calculation-is-converged}}
\sphinxAtStartPar
The free energy hessian requires much more configurations than the SCHA minimization. First of all, to run the free energy Hessian, the SSCHA minimization must end with a gradient that can be decreased indefinitely without decreasing the KL below 0.7 /0.8.
Then you can estimate the error by repeating the hessian calculation with half of the ensemble and check how the frequencies of the hessian changes. This is also a good check for the final error on the frequencies.

\sphinxAtStartPar
You can split your ensemble in two by using the split function.

\sphinxAtStartPar
To split the ensemble, refer to the FAQ {\hyperref[\detokenize{faq:faq-split}]{\sphinxcrossref{\DUrole{std,std-ref}{How do I split the ensemble?}}}}.


\subsection{How do I split the ensemble?}
\label{\detokenize{faq:how-do-i-split-the-ensemble}}\label{\detokenize{faq:faq-split}}
\sphinxAtStartPar
After you load or compute an ensemble you can split it and select only a portion of it to run the code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Assuming you loaded or computed the ensemble inside}
\PYG{c+c1}{\PYGZsh{} ensemble}

\PYG{c+c1}{\PYGZsh{} Let us create a mask that selects only the first half of the ensemble}
\PYG{n}{first\PYGZus{}half\PYGZus{}mask} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{ensemble}\PYG{o}{.}\PYG{n}{N}\PYG{p}{,} \PYG{n}{dtype} \PYG{o}{=} \PYG{n+nb}{bool}\PYG{p}{)}
\PYG{n}{first\PYGZus{}half\PYGZus{}mask}\PYG{p}{[}\PYG{p}{:}\PYG{n}{ensemble}\PYG{o}{.}\PYG{n}{N}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{k+kc}{True}

\PYG{c+c1}{\PYGZsh{} Now we pass the mask to the ensemble to extract a new one}
\PYG{c+c1}{\PYGZsh{} Containing only the configurations that correspond to the True}
\PYG{c+c1}{\PYGZsh{} values of the mask}
\PYG{n}{first\PYGZus{}half\PYGZus{}ensemble} \PYG{o}{=} \PYG{n}{ensemble}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{n}{first\PYGZus{}half\PYGZus{}mask}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
After this code, the varialbe first\_half\_ensemble is a sscha.Ensemble.Ensemble that
can be used for any caluclation.


\subsection{How can I add more configurations to an existing ensemble?}
\label{\detokenize{faq:how-can-i-add-more-configurations-to-an-existing-ensemble}}
\sphinxAtStartPar
You can use the split and merge functions of the Ensemble class.
First of all you generate a new ensemble, you compute the energy and force for that ensemble,
then you merge it inside another one.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Load the original ensemble (first population with 1000 configurations)}
\PYG{n}{ens} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{p}{(}\PYG{n}{dynmat}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{dynmat}\PYG{o}{.}\PYG{n}{GetSupercell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ens}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data\PYGZus{}dir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{population} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Generate a new ensemble with other 1000 configurations}
\PYG{n}{new\PYGZus{}ensemble} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{o}{.}\PYG{n}{Ensemble}\PYG{p}{(}\PYG{n}{dynmat}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{dynmat}\PYG{o}{.}\PYG{n}{GetSupercell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{new\PYGZus{}ensemble}\PYG{o}{.}\PYG{n}{generate}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compute the energy and forces for the new ensemble}
\PYG{c+c1}{\PYGZsh{} For example in this case we assume to have initialized \PYGZsq{}calc\PYGZsq{} as an ASE calculator.}
\PYG{c+c1}{\PYGZsh{} But you can also save it with a different population,}
\PYG{c+c1}{\PYGZsh{} manually compute energy and forces, and then load again the ensemble.}
\PYG{n}{new\PYGZus{}ensemble}\PYG{o}{.}\PYG{n}{get\PYGZus{}energy\PYGZus{}forces}\PYG{p}{(}\PYG{n}{calc}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Merge the two ensembles}
\PYG{n}{ens}\PYG{o}{.}\PYG{n}{merge}\PYG{p}{(}\PYG{n}{new\PYGZus{}ensemble}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Now ens contains the two ensembles. You can save it or directly use it for a SSCHA calculation}
\PYG{n}{ens}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data\PYGZus{}dir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{population} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Indeed, to avoid mistakes, when merging the ensemble you must be carefull that the dynamical matrix and the temperature used to generate both ensembles are the same.


\subsection{How does the error over the gradients scale with the number of configurations?}
\label{\detokenize{faq:how-does-the-error-over-the-gradients-scale-with-the-number-of-configurations}}\begin{quote}

\sphinxAtStartPar
The error scales as any stochastic method, with the inverse of the square root of the number of configurations. So to double the accuracy, the number of configurations must be multiplied by 4.
\end{quote}


\subsection{I cannot remove the pressure anisotropy after relaxing the cell, what is happening?}
\label{\detokenize{faq:i-cannot-remove-the-pressure-anisotropy-after-relaxing-the-cell-what-is-happening}}
\sphinxAtStartPar
Variable cell calculation is a tricky algorithm. It could be that your bulk modulus is strongly anisotropic, so the algorithm has difficulties in optimizing well.
In general, the stress tensor is also affected by the stochastic error, so it is impossible to completely remove anisotropy. However, a converged result is one in which the residual anisotropy in the stress tensor is comparable to the stochastic error on the stress tensor.
If you are not able to converge, you can either increase the number of configurations, modify the bulk\_modulus parameter (increase it if the stress change too much between two populations, decrease it if it does not changes enough) or fix the overall volume (by using the fix\_volume flag in the \&relax namespace or the vc\_relax method if you are using the python script).

\sphinxAtStartPar
Fixing the volume improves the convergence of the variable cell algorithm (using the fix\_volume = True argument of the vc\_relax method).


\subsection{How do I choose the appropriate value of Kong\sphinxhyphen{}Liu effective sample size or ratio?}
\label{\detokenize{faq:how-do-i-choose-the-appropriate-value-of-kong-liu-effective-sample-size-or-ratio}}
\sphinxAtStartPar
The Kong\sphinxhyphen{}Liu (KL) effective sample size is an estimation of how good is the extracted set of configurations to describe the BO landscape around the current values of the dynamical matrix and the centroid position. After the ensemble is generated, the KL sample size matches with the actual number of configurations, however, as the minimization goes, the KL sample size is reduced. The code stops when the KL sample size is below a certain threshold.

\sphinxAtStartPar
The default value for the Kong\sphinxhyphen{}Liu threshold ratio is 0.5 (effective sample size = 0.5 the original number of configurations). This is a good and safe value for most situations. However, if you are very far from the minimum and the gradient is big, you can trust it even if it is very noisy. For this reason, you can lower the Kong\sphinxhyphen{}Liu ratio to 0.2 or 0.1. However, notice that by construction the KL effective sample size is always bigger than 2.  Therefore, if you use 10 configurations, and you set a threshold ratio below 0.2, you will never reach the threshold, and your minimization will continue forever (going into a very bad regime where you are minimizing something completely random). On the other side, on some very complex systems close to the minimum, it could be safe to increase the KL ratio even at 0.6.


\section{Post\sphinxhyphen{}processing the output}
\label{\detokenize{faq:post-processing-the-output}}

\subsection{How do I plot the phonon dispersion after the calculation?}
\label{\detokenize{faq:how-do-i-plot-the-phonon-dispersion-after-the-calculation}}
\sphinxAtStartPar
See {\hyperref[\detokenize{start:plot-the-phonon-dispersion}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot the phonon dispersion}}}} section.


\subsection{How do I plot the frequencies of the dynamical matrix during the optimization?}
\label{\detokenize{faq:how-do-i-plot-the-frequencies-of-the-dynamical-matrix-during-the-optimization}}
\sphinxAtStartPar
To check if the SSCHA is converging, you should plot the dynamical matrix’s frequencies during the minimization.
In particular, you should look if, between different populations, the evolution of each frequency is consistent. If it seems that frequencies are evolving randomly from a population to the next one, you should increase the number of configurations, otherwise, you can keep the number fixed.

\sphinxAtStartPar
The code can print the frequencies at each step.
If you run the code with an input script, you should provide in the \&utils tag the filename for the frequencies:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZam{}}\PYG{n}{utils}
\PYG{+w}{    }\PYG{n}{save\PYGZus{}frequencies}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}minim\PYGZus{}info\PYGZdq{}}
\PYG{p}{\PYGZam{}}\PYG{n}{utils}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can use the same function from the python script by calling a custom function that saves the frequencies after each optimization step. The Utilities module of the SSCHA offers this function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{IO\PYGZus{}freq} \PYG{o}{=} \PYG{n}{sscha}\PYG{o}{.}\PYG{n}{Utilities}\PYG{o}{.}\PYG{n}{IOInfo}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{IO\PYGZus{}freq}\PYG{o}{.}\PYG{n}{SetupSaving}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{minim\PYGZus{}info}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initialize the minimizer as minim [...]}
\PYG{n}{minim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{custom\PYGZus{}function\PYGZus{}post} \PYG{o}{=} \PYG{n}{IO\PYGZus{}freq}\PYG{o}{.}\PYG{n}{CFP\PYGZus{}SaveAll}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then, while running you can plot all the information about the minimization with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }sscha\PYGZhy{}plot\PYGZhy{}data.py minim\PYGZus{}info

\PYG{g+go}{And you will see both frequencies, free energy, gradients and everything how it evolves during the}
\PYG{g+go}{minimization.}

\PYG{g+go}{If you are using a version older than 1.2, the previous command should be replaced with:}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }plot\PYGZus{}frequencies.py minim\PYGZus{}info
\end{sphinxVerbatim}

\sphinxAtStartPar
If you restart the calculation and save it in multiple files, you can concatenate the results with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }sscha\PYGZhy{}plot\PYGZhy{}data.py minim\PYGZus{}info1 minim\PYGZus{}info2 ...
\end{sphinxVerbatim}


\section{Constrains and custom minimization}
\label{\detokenize{faq:constrains-and-custom-minimization}}

\subsection{How do I lock modes from m to n in the minimization?}
\label{\detokenize{faq:how-do-i-lock-modes-from-m-to-n-in-the-minimization}}
\sphinxAtStartPar
Constrains to the minimization within the mode space may be added in both the input file (for the stand\sphinxhyphen{}alone execution) and in the python script.
In the input script, inside the namespace \sphinxstylestrong{\&utils}, you should add:

\sphinxAtStartPar
\sphinxstylestrong{mu\_free\_start = 30} and \sphinxstylestrong{mu\_free\_end = 36} : optimize only between mode 30 and 36 (for each q point).

\sphinxAtStartPar
You can also use the keywords \sphinxstylestrong{mu\_lock\_start} and \sphinxstylestrong{mu\_lock\_end} to freeze only a subset of modes.

\sphinxAtStartPar
You can also choose if you want to freeze only the dynamical matrix or also the structure relaxation along with those directions, by picking:

\sphinxAtStartPar
\sphinxstylestrong{project\_dyn = .true.} and \sphinxstylestrong{project\_structure = .false.}. In this way, I freeze only the dynamical matrix along with the specified modes, but not the structure.

\sphinxAtStartPar
Modes may be also locked within the python scripting. Look at the LockModes example in the Examples directory.

\sphinxAtStartPar
TODO: Add the same guide for the python code


\subsection{How do I lock a special atom in the minimization?}
\label{\detokenize{faq:how-do-i-lock-a-special-atom-in-the-minimization}}\begin{quote}

\sphinxAtStartPar
More complex constraints may be activated in the minimization, but their use is limited within the python scripting.
You can write your constraining function that will be applied to the structure gradient or the dynamical matrix gradient.
This function should take as input the two gradients (dynamical matrix and structure) and operate directly on them.
Then it can be passed to the minimization engine as \sphinxstyleemphasis{custom\_function\_gradient}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LIST\PYGZus{}OF\PYGZus{}ATOMS\PYGZus{}TO\PYGZus{}FIX} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{k}{def} \PYG{n+nf}{fix\PYGZus{}atoms}\PYG{p}{(}\PYG{n}{gradient\PYGZus{}dyn}\PYG{p}{,} \PYG{n}{gradient\PYGZus{}struct}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Fix the atoms in the list}
    \PYG{n}{gradient\PYGZus{}struct}\PYG{p}{[}\PYG{n}{LIST\PYGZus{}OF\PYGZus{}ATOMS\PYGZus{}TO\PYGZus{}FIX}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{minim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(} \PYG{n}{custom\PYGZus{}function\PYGZus{}gradient} \PYG{o}{=} \PYG{n}{fix\PYGZus{}atoms} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, \sphinxcode{\sphinxupquote{minim}} is the \sphinxcode{\sphinxupquote{SSCHA\_Minimizer}} class. In this case, we only fix the structure gradient. However, the overall gradient will have a translation (acoustic sum rule is violated). Be very careful when doing this kind of constrains, and check if it is really what you want.

\sphinxAtStartPar
A more detailed and working example that fixes also the degrees of freedom of the dynamical matrix is reported in the FixAtoms example.
\end{quote}

\sphinxstepscope


\chapter{THE API}
\label{\detokenize{apireference:the-api}}\label{\detokenize{apireference::doc}}
\sphinxAtStartPar
This chapter contains the documentation for the main methods of the python\sphinxhyphen{}sscha code.
It can be used both by advanced users, that wants to exploit python\sphinxhyphen{}sscha as a library,
or developers, willing to add new features to the code (or adapt existing ones for their purposes).

\sphinxAtStartPar
The API is divided into Modules.


\section{The Ensemble Module}
\label{\detokenize{apireference:the-ensemble-module}}
\sphinxAtStartPar
This module deals with the ensembles of configurations.
It is used to generate random configurations from the dynamical matrix, to compute observables on the ensemble used in the SSCHA optimization.
These include the average force on atoms, the gradient of the SSCHA minimization, the quantum\sphinxhyphen{}thermal stress tensor, as well as properties of
the ensemble, like reweighting.
\index{Ensemble (class in sscha.Ensemble)@\spxentry{Ensemble}\spxextra{class in sscha.Ensemble}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{sscha.Ensemble.}}\sphinxbfcode{\sphinxupquote{Ensemble}}}{\emph{\DUrole{n}{dyn0}}, \emph{\DUrole{n}{T0}}, \emph{\DUrole{n}{supercell}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures\index{compute\_ensemble() (sscha.Ensemble.Ensemble method)@\spxentry{compute\_ensemble()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.compute_ensemble}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_ensemble}}}{\emph{\DUrole{n}{calculator}}, \emph{\DUrole{n}{compute\_stress}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{stress\_numerical}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cluster}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures

\subsection{GET ENERGY AND FORCES}
\label{\detokenize{apireference:get-energy-and-forces}}
\sphinxAtStartPar
This is the generic function to compute forces and stresses.
It can be used both with clusters, and with simple ase calculators


\subsubsection{Paramters}
\label{\detokenize{apireference:paramters}}\begin{quote}
\begin{description}
\sphinxlineitem{calculator:}
\sphinxAtStartPar
The ase calculator

\sphinxlineitem{compute\_stress: bool}
\sphinxAtStartPar
If true compute the stress

\sphinxlineitem{stress\_numerical}{[}bool{]}
\sphinxAtStartPar
Compute the stress tensor with finite difference,
this is not possible with clusters

\sphinxlineitem{cluster: Cluster, optional}
\sphinxAtStartPar
The cluster in which to send the calculation.
If None the calculation is performed on the same computer of
the sscha code.

\end{description}
\end{quote}

\end{fulllineitems}

\index{convert\_units() (sscha.Ensemble.Ensemble method)@\spxentry{convert\_units()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.convert_units}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convert\_units}}}{\emph{\DUrole{n}{new\_units}}}{}
\pysigstopsignatures

\subsection{CONVERT ALL THE VARIABLE IN A COHERENT UNIT OF MEASUREMENTS}
\label{\detokenize{apireference:convert-all-the-variable-in-a-coherent-unit-of-measurements}}
\sphinxAtStartPar
This function is used to jump between several unit of measurement.
You should always call this function before processing data assuming
a particular kind of units.
\begin{description}
\sphinxlineitem{Supported units are:}\begin{itemize}
\item {} \begin{description}
\sphinxlineitem{“default” :}
\sphinxAtStartPar
This is the default units. Here the forces are Ry/A displacements and structure are in A
Dynamical matrix is in Ry/bohr\textasciicircum{}2. Mass is in Ry units

\end{description}

\item {} \begin{description}
\sphinxlineitem{“hartree” :}
\sphinxAtStartPar
Here, everything is stored in Ha units.

\end{description}

\end{itemize}

\end{description}


\subsubsection{Parameters}
\label{\detokenize{apireference:parameters}}\begin{itemize}
\item {} \begin{description}
\sphinxlineitem{new\_units}{[}string{]}
\sphinxAtStartPar
The target units

\end{description}

\end{itemize}

\end{fulllineitems}

\index{generate() (sscha.Ensemble.Ensemble method)@\spxentry{generate()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.generate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{generate}}}{\emph{\DUrole{n}{N}}, \emph{\DUrole{n}{evenodd}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{project\_on\_modes}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{sobol}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sobol\_scramble}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sobol\_scatter}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\pysigstopsignatures

\subsection{GENERATE THE ENSEMBLE}
\label{\detokenize{apireference:generate-the-ensemble}}
\sphinxAtStartPar
This subroutine generates the ensemble from dyn0 and T0 setted when this
class is created.
You still need to generate the forces for the configurations.


\subsubsection{Parameters}
\label{\detokenize{apireference:id1}}\begin{quote}
\begin{description}
\sphinxlineitem{N}{[}int{]}
\sphinxAtStartPar
The number of random configurations to be extracted

\sphinxlineitem{evenodd}{[}bool, optional{]}
\sphinxAtStartPar
If true for each configuration also the opposite is extracted

\sphinxlineitem{project\_on\_modes}{[}ndarray(size=(3*nat\_sc, nproj)), optional{]}
\sphinxAtStartPar
If different from None the displacements are projected on the
given modes.

\sphinxlineitem{sobol}{[}bool, optional (Default = False){]}
\sphinxAtStartPar
Defines if the calculation uses random Gaussian generator or Sobol Gaussian generator.

\sphinxlineitem{sobol\_scramble}{[}bool, optional (Default = False){]}
\sphinxAtStartPar
Set the optional scrambling of the generated numbers taken from the Sobol sequence.

\sphinxlineitem{sobol\_scatter}{[}real (0.0 to 1) (Deafault = 0.0){]}
\sphinxAtStartPar
Set the scatter parameter to displace the Sobol positions randommly.

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_average\_energy() (sscha.Ensemble.Ensemble method)@\spxentry{get\_average\_energy()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_average_energy}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_average\_energy}}}{\emph{\DUrole{n}{subtract\_sscha}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{return\_error}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{GET ENERGY}
\label{\detokenize{apireference:get-energy}}
\sphinxAtStartPar
This is the average of the energy
\begin{equation*}
\begin{split}\left< E\right> = \frac{1}{N} \sum_{i = 1}^{N} E_i \rho_i\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\rho_i\) is the ratio between the probability of extracting the configuration \$i\$
with the current dynamical matrix and with the dynamical matrix used to extract the ensemble.


\subsubsection{Parameters}
\label{\detokenize{apireference:id2}}\begin{quote}
\begin{description}
\sphinxlineitem{subtract\_sscha}{[}bool, optional, default False{]}
\sphinxAtStartPar
If true, the average difference of energy respect to the sscha one is returned. This
is good, because you can compute analytically the sscha energy and sum it on an infinite
ensembe. Do in this way to suppress the stochastic noise.

\sphinxlineitem{return\_error}{[}bool, optional, default False{]}
\sphinxAtStartPar
If true also the error is returned as a second value

\end{description}
\end{quote}


\subsubsection{Examples}
\label{\detokenize{apireference:examples}}
\sphinxAtStartPar
Example where ensemble is a correctly initialized self variable

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{energy} \PYG{o}{=} \PYG{n}{ensemble}\PYG{o}{.}\PYG{n}{get\PYGZus{}average\PYGZus{}energy}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following example return also the stochastic error
\textgreater{}\textgreater{}\textgreater{} energy, error\_on\_energy = ensemble.get\_average\_energy(return\_error = True)

\end{fulllineitems}

\index{get\_average\_forces() (sscha.Ensemble.Ensemble method)@\spxentry{get\_average\_forces()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_average_forces}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_average\_forces}}}{\emph{\DUrole{n}{get\_error}}, \emph{\DUrole{n}{in\_unit\_cell}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures

\subsection{GET FORCES}
\label{\detokenize{apireference:get-forces}}
\sphinxAtStartPar
This is the average of the forces that acts on the atoms
\begin{equation*}
\begin{split}\left< \vec F\right> = \frac{1}{N} \sum_{i = 1}^{N}\vec F_i \rho_i\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\rho_i\) is the ratio between the probability of extracting the configuration \(i\)
with the current dynamical matrix and with the dynamical matrix used to extract the ensemble.


\subsubsection{Parameters}
\label{\detokenize{apireference:id3}}\begin{itemize}
\item {} \begin{description}
\sphinxlineitem{get\_error}{[}bool{]}
\sphinxAtStartPar
If true the error is also returned (as get\_free\_energy).

\end{description}

\item {} \begin{description}
\sphinxlineitem{in\_unit\_cell}{[}bool, optional{]}
\sphinxAtStartPar
If True (default True) the mean force is averaged on all the atoms in the supercell,
then it returns the forces that acts on the unit cell atoms only.

\end{description}

\end{itemize}

\end{fulllineitems}

\index{get\_average\_stress() (sscha.Ensemble.Ensemble method)@\spxentry{get\_average\_stress()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_average_stress}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_average\_stress}}}{}{}
\pysigstopsignatures

\subsection{GET THE AVERAGE STRESS}
\label{\detokenize{apireference:get-the-average-stress}}
\sphinxAtStartPar
This gets only the ab\sphinxhyphen{}initio average of the stress tensor
\begin{equation*}
\begin{split}P_{\alpha\beta} = \left<P_{\alpha\beta}\right>\end{split}
\end{equation*}
\end{fulllineitems}

\index{get\_covmat\_from\_ensemble() (sscha.Ensemble.Ensemble method)@\spxentry{get\_covmat\_from\_ensemble()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_covmat_from_ensemble}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_covmat\_from\_ensemble}}}{}{}
\pysigstopsignatures

\subsection{GET THE COVARIANCE STOCASTICALLY}
\label{\detokenize{apireference:get-the-covariance-stocastically}}
\sphinxAtStartPar
This method is for testing, allows to use the ensemble to
evaluate the covariance matrix stochastically. It should be equal
to the matrix Upsilon\textasciicircum{}\sphinxhyphen{}1 that is obtained with the GetUpsilonMatrix method
from the Phonons package.
\begin{equation*}
\begin{split}\Upsilon^{-1}_{ab} = \left< u_a u_b\right>\end{split}
\end{equation*}

\subsubsection{Results}
\label{\detokenize{apireference:results}}\begin{quote}
\begin{description}
\sphinxlineitem{cov\_mat}{[}3nat x 3nat, ndarray{]}
\sphinxAtStartPar
A numpy matrix of the covariance matrix.

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_effective\_sample\_size() (sscha.Ensemble.Ensemble method)@\spxentry{get\_effective\_sample\_size()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_effective_sample_size}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_effective\_sample\_size}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get the Kong\sphinxhyphen{}Liu effective sample size with the given importance sampling.

\end{fulllineitems}

\index{get\_energy\_forces() (sscha.Ensemble.Ensemble method)@\spxentry{get\_energy\_forces()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_energy_forces}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_energy\_forces}}}{\emph{\DUrole{n}{ase\_calculator}}, \emph{\DUrole{n}{compute\_stress}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{stress\_numerical}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{skip\_computed}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{GET ENERGY AND FORCES FOR THE CURRENT ENSEMBLE}
\label{\detokenize{apireference:get-energy-and-forces-for-the-current-ensemble}}
\sphinxAtStartPar
This subroutine uses the ase calculator to compute the abinitio energies and forces
of the self ensemble.
This subroutine requires to have ASE installed and properly configured to
interface with your favourite ab\sphinxhyphen{}initio software.


\subsubsection{Parameters}
\label{\detokenize{apireference:id4}}\begin{quote}
\begin{description}
\sphinxlineitem{ase\_calculator}{[}ase.calculator{]}
\sphinxAtStartPar
The ASE interface to the calculator to run the calculation.
also a CellConstructor calculator is accepted

\sphinxlineitem{compute\_stress}{[}bool{]}
\sphinxAtStartPar
If true, the stress is requested from the ASE calculator. Be shure
that the calculator you provide supports stress calculation

\sphinxlineitem{stress\_numerical}{[}bool{]}
\sphinxAtStartPar
If the calculator does not support stress, it can be computed numerically
by doing finite differences.

\sphinxlineitem{skip\_computed}{[}bool{]}
\sphinxAtStartPar
If true the configurations already computed will be skipped.
Usefull if the calculation crashed for some reason.

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_fc\_from\_self\_consistency() (sscha.Ensemble.Ensemble method)@\spxentry{get\_fc\_from\_self\_consistency()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_fc_from_self_consistency}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_fc\_from\_self\_consistency}}}{\emph{\DUrole{n}{subtract\_sscha}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{return\_error}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures\begin{quote}

\sphinxAtStartPar
This function evaluate the self consistent scha equation. This can be used
to evaluate the goodness of the minimization procedure, as well as an
independent minimizer.
\begin{equation*}
\begin{split}\Phi_{ab} = \frac 12 \sum_c \Upsilon_{ac} \left< u_c f_a\right>_{\Phi}\end{split}
\end{equation*}
\sphinxAtStartPar
The previous equation is true only if the \(\Phi\) matrix is the solution
of the SCHA theory. Here :math:{\color{red}\bfseries{}\textasciigrave{}}
\end{quote}
\begin{description}
\sphinxlineitem{ec u\textasciigrave{} are the displacements of the configurations}
\sphinxAtStartPar
and \(f\) are the forces of the real system acting on the simulation.
\begin{quote}
\begin{description}
\sphinxlineitem{subtract\_sscha}{[}bool, optional{]}
\sphinxAtStartPar
This is an optional parameter, if true the forces used to evaluate the
new force constant matrix are subtracted by the sscha forces.
This means that the result is a gradient of the new matrix with respect
to the old one.

\sphinxlineitem{return\_error}{[}bool, optional{]}
\sphinxAtStartPar
If true also the stochastic error is returned.

\end{description}
\end{quote}
\begin{quote}
\begin{description}
\sphinxlineitem{fc}{[}ndarray (3*nat x 3*nat){]}
\sphinxAtStartPar
The real space force constant matrix obtained by the
self\sphinxhyphen{}consistent equation.

\end{description}
\end{quote}

\end{description}

\end{fulllineitems}

\index{get\_free\_energy() (sscha.Ensemble.Ensemble method)@\spxentry{get\_free\_energy()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_free_energy}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_free\_energy}}}{\emph{\DUrole{n}{return\_error}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{SSCHA FREE ENERGY}
\label{\detokenize{apireference:sscha-free-energy}}
\sphinxAtStartPar
Obtain the SSCHA free energy for the system.
This is done by integrating the free energy along the hamiltonians, starting
from current\_dyn to the real system.

\sphinxAtStartPar
The result is in Rydberg
\begin{equation*}
\begin{split}\mathcal F = \mathcal F_0 + \int_0^1 \frac{d\mathcal F_\lambda}{d\lambda} d\lambda\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\lambda\) is the parameter for the adiabatic integration of the hamiltonian.
\begin{equation*}
\begin{split}H(\lambda) = H_0 + (H - H_0) \lambda\end{split}
\end{equation*}
\sphinxAtStartPar
here \(H_0\) is the sscha harmonic hamiltonian, while \(H_1\) is the real hamiltonian
of the system.


\subsubsection{Parameters}
\label{\detokenize{apireference:id7}}\begin{quote}
\begin{description}
\sphinxlineitem{return\_error}{[}bool, optional, default False{]}
\sphinxAtStartPar
If true also the error is returned as a second value.

\end{description}
\end{quote}


\subsubsection{Returns}
\label{\detokenize{apireference:returns}}\begin{quote}
\begin{description}
\sphinxlineitem{float}
\sphinxAtStartPar
The free energy in the current dynamical matrix and at the ensemble temperature

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_free\_energy\_hessian() (sscha.Ensemble.Ensemble method)@\spxentry{get\_free\_energy\_hessian()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_free_energy_hessian}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_free\_energy\_hessian}}}{\emph{\DUrole{n}{include\_v4}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_full\_hessian}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{use\_symmetries}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{return\_d3}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{GET THE FREE ENERGY ODD CORRECTION}
\label{\detokenize{apireference:get-the-free-energy-odd-correction}}
\sphinxAtStartPar
This subroutines computes the odd correction
to the free energy hessian using the fortran subroutines, as describe in the
Bianco paper …

\sphinxAtStartPar
The calculation is performed in the supercell


\subsubsection{Parameters}
\label{\detokenize{apireference:id8}}\begin{quote}
\begin{description}
\sphinxlineitem{include\_v4}{[}bool{]}
\sphinxAtStartPar
If True we include the fourth order force constant matrix.
This requires a lot of memory

\sphinxlineitem{get\_full\_hessian}{[}bool{]}
\sphinxAtStartPar
If True the full hessian matrix is returned, if false, only the correction to
the SSCHA dynamical matrix is returned.

\sphinxlineitem{verbose}{[}bool{]}
\sphinxAtStartPar
If true, the third order force constant tensor is written in output {[}Ha/bohr\textasciicircum{}3 units{]}.
This can be used to interpolate the result on a bigger mesh with cellconstructor.

\sphinxlineitem{use\_symmetries}{[}bool{]}
\sphinxAtStartPar
If true, the d3 and d4 are symmetrized in real space.
It requires that spglib is installed to detect symmetries in the supercell correctly.

\sphinxlineitem{return\_d3}{[}bool{]}
\sphinxAtStartPar
If true, returns also the tensor of three phonon scattering.

\end{description}
\end{quote}


\subsubsection{Returns}
\label{\detokenize{apireference:id9}}\begin{quote}
\begin{description}
\sphinxlineitem{phi\_sc}{[}Phonons(){]}
\sphinxAtStartPar
The dynamical matrix of the free energy hessian in (Ry/bohr\textasciicircum{}2)

\sphinxlineitem{d3}{[}ndarray (size = (3*nat\_sc, 3*nat\_sc, 3*nat\_sc), Optional{]}
\sphinxAtStartPar
Return the three\sphinxhyphen{}phonon\sphinxhyphen{}scattering tensor (in Ry atomic units).
Only if return\_d3 is True.

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_free\_energy\_interpolating() (sscha.Ensemble.Ensemble method)@\spxentry{get\_free\_energy\_interpolating()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_free_energy_interpolating}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_free\_energy\_interpolating}}}{\emph{\DUrole{n}{target\_supercell}}, \emph{\DUrole{n}{support\_dyn\_coarse}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{support\_dyn\_fine}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{error\_on\_imaginary\_frequency}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{return\_error}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{GET THE FREE ENERGY IN A BIGGER CELL}
\label{\detokenize{apireference:get-the-free-energy-in-a-bigger-cell}}
\sphinxAtStartPar
This is a trick to interpolate the free energy in the
infinite volume limit.

\sphinxAtStartPar
Note, this function report the free eenrgy in the primitive cell, while the method get\_free\_energy
returns the energy in the supercell.


\subsubsection{Parameters}
\label{\detokenize{apireference:id10}}\begin{quote}
\begin{description}
\sphinxlineitem{target\_supercell}{[}list (N, N, N){]}
\sphinxAtStartPar
A list of three indices, where N is the dimension
of the target supercell on which you want to interpolate.

\sphinxlineitem{support\_dyn{[}coarse/fine{]}}{[}Phonons() Optional{]}
\sphinxAtStartPar
The harmonic dynamical matrix in the current/target\_supercell
This is optional, it can be used to achieve a better
interpolation. If provided only the difference between
the harmonic dyn and the current dyn is interpolated.

\sphinxlineitem{error\_on\_imaginary\_frequency}{[}bool{]}
\sphinxAtStartPar
If Fase (default True) it will ignore imaginary frequencies
arising from the interpolation. Otherwise an exception will
be raised.

\sphinxlineitem{return\_error}{[}bool{]}
\sphinxAtStartPar
As the normal get\_free\_energy, if this flag is True, the stochastic error is returned.

\end{description}
\end{quote}


\subsubsection{Returns}
\label{\detokenize{apireference:id11}}\begin{quote}
\begin{description}
\sphinxlineitem{free\_energy}{[}float{]}
\sphinxAtStartPar
The free energy in the unit\_cell volume {[}in Ry{]}. Note.
This free energy is rescaled on the unit cell volume,
it is a different behaviour with respect to get\_free\_energy.

\sphinxlineitem{error\_on free energy}{[}float{]}
\sphinxAtStartPar
The stochastic error, it is returned only if requested.

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_noncomputed() (sscha.Ensemble.Ensemble method)@\spxentry{get\_noncomputed()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_noncomputed}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_noncomputed}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Get another ensemble with only the non computed configurations.
This may be used to resubmit only the non computed values

\end{fulllineitems}

\index{get\_odd\_realspace() (sscha.Ensemble.Ensemble method)@\spxentry{get\_odd\_realspace()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_odd_realspace}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_odd\_realspace}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
This is a testing function to compute the odd3 correction
using the real space v3 (similar to the raffaello first implementation)

\end{fulllineitems}

\index{get\_preconditioned\_gradient() (sscha.Ensemble.Ensemble method)@\spxentry{get\_preconditioned\_gradient()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_preconditioned_gradient}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_preconditioned\_gradient}}}{\emph{\DUrole{n}{subtract\_sscha}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{return\_error}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{use\_ups\_supercell}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{preconditioned}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{fast\_grad}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures

\subsection{SELF CONSISTENT SCHA EQUATION}
\label{\detokenize{apireference:self-consistent-scha-equation}}
\sphinxAtStartPar
This function evaluate the self consistent scha equation. This can be used
to evaluate the goodness of the minimization procedure, as well as an
independent minimizer. This is the same as get\_fc\_from\_self\_consistency,
but works also with supercell
\begin{equation*}
\begin{split}\Phi_{ab} = \sum_c \upsilon_{ac} \left< u_c f_a\right>_{\Phi}\end{split}
\end{equation*}
\sphinxAtStartPar
The previous equation is true only if the \(\Phi\) matrix is the solution
of the SCHA theory. Here \(\vec u\) are the displacements of the configurations
and \(f\) are the forces of the real system acting on the simulation.

\sphinxAtStartPar
NOTE: It does not takes into account for the symmetrization.


\subsubsection{Parameters}
\label{\detokenize{apireference:id12}}\begin{quote}
\begin{description}
\sphinxlineitem{subtract\_sscha}{[}bool, optional{]}
\sphinxAtStartPar
This is an optional parameter, if true the forces used to evaluate the
new force constant matrix are subtracted by the sscha forces.
This means that the result is a gradient of the new matrix with respect
to the old one.

\sphinxlineitem{return\_error}{[}bool, optional{]}
\sphinxAtStartPar
If true also the stochastic error is returned.

\sphinxlineitem{use\_ups\_supercell}{[}bool, optional{]}
\sphinxAtStartPar
If true the gradient is computed enterely in real space, and then transformed
with fourier in q space. This is computationally heavier, but can be used
to test if everything is working correctly. For now this flag
is ignored and always True.

\sphinxlineitem{preconitioned}{[}int, optional{]}
\sphinxAtStartPar
If 1 (default) the gradient is returned multiplied by the preconditioned,
otherwise it is returned as it should be.

\end{description}
\end{quote}


\subsubsection{Results}
\label{\detokenize{apireference:id13}}\begin{quote}
\begin{description}
\sphinxlineitem{fc}{[}ndarray (nq x 3*nat x 3*nat){]}
\sphinxAtStartPar
The real space force constant matrix obtained by the
self\sphinxhyphen{}consistent equation.

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_stress\_tensor() (sscha.Ensemble.Ensemble method)@\spxentry{get\_stress\_tensor()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.get_stress_tensor}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_stress\_tensor}}}{\emph{\DUrole{n}{offset\_stress}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{add\_centroid\_contrib}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{use\_spglib}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{GET STRESS TENSOR}
\label{\detokenize{apireference:get-stress-tensor}}
\sphinxAtStartPar
The following subroutine computes the anharmonic stress tensor
calling the fortran code get\_stress\_tensor.
Note that the stress tensor is symmetrized to satisfy the cell constraint.

\sphinxAtStartPar
NOTE: unit of measure is Ry/bohr\textasciicircum{}3 to match the quantum espresso one


\subsubsection{Parameters}
\label{\detokenize{apireference:id14}}\begin{quote}
\begin{description}
\sphinxlineitem{offset\_stress}{[}3x3 matrix, optional{]}
\sphinxAtStartPar
An offset stress to be subtracted to the real stress tensor.
Usefull if you want to compute just the anharmonic contribution.

\sphinxlineitem{add\_centroid\_contrib}{[}bool, optional{]}
\sphinxAtStartPar
If true the contribution of the centroid is added. This is always zero when
the system is relaxed.

\sphinxlineitem{use\_spglib}{[}bool{]}
\sphinxAtStartPar
If true use the spglib library to perform the symmetrization

\end{description}
\end{quote}


\subsubsection{Results}
\label{\detokenize{apireference:id15}}\begin{quote}
\begin{description}
\sphinxlineitem{stress\_tensor}{[}3x3 matrix{]}
\sphinxAtStartPar
The anharmonic stress tensor obtained by averaging both the ab\sphinxhyphen{}initio
stresses and correcting with the sscha non\sphinxhyphen{}linearity.

\sphinxlineitem{err\_stress}{[}3x3 matrix{]}
\sphinxAtStartPar
The matrix of the error on the stress tensor.

\end{description}
\end{quote}

\end{fulllineitems}

\index{init\_from\_structures() (sscha.Ensemble.Ensemble method)@\spxentry{init\_from\_structures()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.init_from_structures}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_from\_structures}}}{\emph{\DUrole{n}{structures}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Initialize the ensemble from the given list of structures


\subsection{Parameters}
\label{\detokenize{apireference:id16}}\begin{quote}
\begin{description}
\sphinxlineitem{structures}{[}list of structures{]}
\sphinxAtStartPar
The list of structures used to initialize the ensemble

\end{description}
\end{quote}

\end{fulllineitems}

\index{load() (sscha.Ensemble.Ensemble method)@\spxentry{load()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.load}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load}}}{\emph{\DUrole{n}{data\_dir}}, \emph{\DUrole{n}{population}}, \emph{\DUrole{n}{N}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{load\_displacements}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{raise\_error\_on\_not\_found}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{load\_noncomputed\_ensemble}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{LOAD THE ENSEMBLE}
\label{\detokenize{apireference:load-the-ensemble}}
\sphinxAtStartPar
This function load the ensemble from a standard calculation.

\sphinxAtStartPar
The files need to be organized as follows

\sphinxAtStartPar
data\_dir / scf\_populationX\_Y.dat
data\_dir / energies\_supercell\_populationX.dat
data\_dir / forces\_populationX\_Y.dat
data\_dir / pressures\_populationX\_Y.dat
data\_dir / u\_populationX\_Y.dat

\sphinxAtStartPar
X = population
Y = the configuration id (starting from 1 to N included, fortran convention)

\sphinxAtStartPar
The files scf\_population\_X\_Y.dat must contain the scf file of the structure.
It should be in alat units, matching the same alat defined in the starting
dynamical matrix.

\sphinxAtStartPar
The energies\_supercell.dat file must contain the total energy in Ry for
each configuration.

\sphinxAtStartPar
The forces\_populationX\_Y contains the


\subsubsection{Parameters}
\label{\detokenize{apireference:id17}}\begin{quote}
\begin{description}
\sphinxlineitem{data\_dir}{[}str{]}
\sphinxAtStartPar
The path to the directory containing the ensemble. If you used
the fortran sscha.x code it should match the data\_dir option of the
input file.

\sphinxlineitem{population}{[}int{]}
\sphinxAtStartPar
The info to distinguish between several ensembles generated in the
same data\_dir. This also should match the correspective property
of the fortran sscha.x input file.

\sphinxlineitem{N}{[}int{]}
\sphinxAtStartPar
The dimension of the ensemble. This should match the n\_random
variable from the fortran sscha.x input file.

\sphinxlineitem{verbose}{[}bool, optional{]}
\sphinxAtStartPar
If true (default false) prints the real timing of the different part
during the loading.

\sphinxlineitem{load\_displacement: bool}
\sphinxAtStartPar
If true the structures are loaded from the u\_populationX\_Y.dat files,
otherwise they are loaded from the scf\_populationX\_Y.dat files.

\sphinxlineitem{raise\_error\_on\_not\_found}{[}bool{]}
\sphinxAtStartPar
If true, raises an error if one force file is missing

\sphinxlineitem{load\_noncomputed\_ensemble: bool}
\sphinxAtStartPar
If True, it allows for loading an ensemble where some of the configurations forces and stresses are missing.
Note that it must be compleated before running a SCHA minimization

\end{description}
\end{quote}

\end{fulllineitems}

\index{load\_bin() (sscha.Ensemble.Ensemble method)@\spxentry{load\_bin()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.load_bin}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_bin}}}{\emph{\DUrole{n}{data\_dir}}, \emph{\DUrole{n}{population\_id}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{avoid\_loading\_dyn}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{LOAD THE BINARY ENSEMBLE}
\label{\detokenize{apireference:load-the-binary-ensemble}}
\sphinxAtStartPar
This function loads the ensemble saved with save\_bin(…)


\subsubsection{Parameters}
\label{\detokenize{apireference:id18}}\begin{quote}
\begin{description}
\sphinxlineitem{data\_dir}{[}string{]}
\sphinxAtStartPar
The directory containing the ensemble

\sphinxlineitem{population\_id}{[}int{]}
\sphinxAtStartPar
The esnemble population identifier.

\sphinxlineitem{avoid\_loading\_dyn}{[}bool{]}
\sphinxAtStartPar
If true, the dynamical matrix is not loaded.

\end{description}
\end{quote}

\end{fulllineitems}

\index{load\_from\_calculator\_output() (sscha.Ensemble.Ensemble method)@\spxentry{load\_from\_calculator\_output()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.load_from_calculator_output}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_from\_calculator\_output}}}{\emph{\DUrole{n}{directory}}, \emph{\DUrole{n}{out\_ext}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.pwo\textquotesingle{}}}}{}
\pysigstopsignatures

\subsection{LOAD THE ENSEMBLE FROM A CALCULATION}
\label{\detokenize{apireference:load-the-ensemble-from-a-calculation}}
\sphinxAtStartPar
This subroutine allows to directly load the ensemble from the output files
of a calculation. This works and has been tested for quantum espresso,
however in principle any output file from an ase supported format
should be readed.

\sphinxAtStartPar
NOTE: This subroutine requires ASE to be correctly installed.


\subsubsection{Parameters}
\label{\detokenize{apireference:id19}}\begin{quote}
\begin{description}
\sphinxlineitem{directory}{[}string{]}
\sphinxAtStartPar
Path to the directory that contains the output of the calculations

\sphinxlineitem{out\_ext}{[}string{]}
\sphinxAtStartPar
The extension of the files that will be readed.

\end{description}
\end{quote}

\end{fulllineitems}

\index{merge() (sscha.Ensemble.Ensemble method)@\spxentry{merge()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.merge}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{merge}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures

\subsection{MERGE TWO ENSEMBLES}
\label{\detokenize{apireference:merge-two-ensembles}}
\sphinxAtStartPar
This function will merge two ensembles together.


\subsubsection{Parameters}
\label{\detokenize{apireference:id20}}\begin{quote}
\begin{description}
\sphinxlineitem{other}{[}Ensemble(){]}
\sphinxAtStartPar
Another ensemble to be merge with. It must be generated by the same dynamical matrix
as this one, otherwise wired things will happen.

\end{description}
\end{quote}

\end{fulllineitems}

\index{remove\_noncomputed() (sscha.Ensemble.Ensemble method)@\spxentry{remove\_noncomputed()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.remove_noncomputed}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{remove\_noncomputed}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Removed all the incomplete calculation from the ensemble.
It may be used to run a minimization even if the ensemble was not completely calculated.

\end{fulllineitems}

\index{save() (sscha.Ensemble.Ensemble method)@\spxentry{save()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{data\_dir}}, \emph{\DUrole{n}{population}}, \emph{\DUrole{n}{use\_alat}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{SAVE THE ENSEMBLE}
\label{\detokenize{apireference:save-the-ensemble}}
\sphinxAtStartPar
This function saves the ensemble in a way the original fortran SSCHA code can read it.
Look at the load function documentation to see clearely how it is saved.

\sphinxAtStartPar
NOTE: This method do not save the dynamical matrix used to generate the ensemble (i.e. self.dyn\_0)
remember to save it separately to really save all the info about the ensemble.


\subsubsection{Parameters}
\label{\detokenize{apireference:id21}}\begin{quote}
\begin{description}
\sphinxlineitem{data\_dir}{[}string{]}
\sphinxAtStartPar
Path to the directory in which the data will be saved. If it does not exists, it will be created

\sphinxlineitem{population}{[}int{]}
\sphinxAtStartPar
The id of the population, usefull if you want to save more ensemble in the same data\_dir without overwriting
the data.

\sphinxlineitem{use\_alat}{[}bool{]}
\sphinxAtStartPar
If true the scf\_populationX\_Y.dat files will be saved in alat units, as specified by the dynamical matrix.
Also the unit cell will be omitted. This is done to preserve retrocompatibility with ensembles generated by
older versions of the sscha code

\end{description}
\end{quote}

\end{fulllineitems}

\index{save\_bin() (sscha.Ensemble.Ensemble method)@\spxentry{save\_bin()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.save_bin}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save\_bin}}}{\emph{\DUrole{n}{data\_dir}}, \emph{\DUrole{n}{population\_id}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
\pysigstopsignatures

\subsection{FAST SAVE OF THE ENSEMBLE}
\label{\detokenize{apireference:fast-save-of-the-ensemble}}
\sphinxAtStartPar
This function is a fast way of saving the ensemble.
It is faster and make use of less disk space than the save.
The drawback is that can only be opened with numpy


\subsubsection{Parameters}
\label{\detokenize{apireference:id22}}\begin{quote}
\begin{description}
\sphinxlineitem{data\_dir}{[}string{]}
\sphinxAtStartPar
path to the folder in which the ensemble is saved

\sphinxlineitem{population\_id}{[}int{]}
\sphinxAtStartPar
The id of the population. This can be used to save
several ensembles in the same data\_dir

\end{description}
\end{quote}

\end{fulllineitems}

\index{save\_enhanced\_xyz() (sscha.Ensemble.Ensemble method)@\spxentry{save\_enhanced\_xyz()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.save_enhanced_xyz}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save\_enhanced\_xyz}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{append\_mode}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{stress\_key}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}virial\textquotesingle{}}}, \emph{\DUrole{n}{forces\_key}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}force\textquotesingle{}}}, \emph{\DUrole{n}{energy\_key}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}energy\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Save the ensemble as an enhanced xyz.

\sphinxAtStartPar
This is the default format for training the GAP potentials with quippy.


\subsection{Parameters}
\label{\detokenize{apireference:id23}}\begin{quote}
\begin{description}
\sphinxlineitem{filename}{[}string{]}
\sphinxAtStartPar
Path to the xyz file in which to save.

\sphinxlineitem{append\_mode}{[}bool{]}
\sphinxAtStartPar
If true, does not overwrite the previous existing file, but append the ensemble on the bottom.
This is the way to concatenate easily more ensembles.

\end{description}
\end{quote}

\end{fulllineitems}

\index{save\_extxyz() (sscha.Ensemble.Ensemble method)@\spxentry{save\_extxyz()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.save_extxyz}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save\_extxyz}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{append\_mode}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures

\subsection{SAVE INTO EXTXYZ FORMAT}
\label{\detokenize{apireference:save-into-extxyz-format}}
\sphinxAtStartPar
ASE extxyz format is used for build the training set for the nequip and allegro neural network potentials.


\subsubsection{Parameters}
\label{\detokenize{apireference:id24}}\begin{quote}
\begin{description}
\sphinxlineitem{filename}{[}str{]}
\sphinxAtStartPar
The path to the .extxyz file containing the ensemble

\sphinxlineitem{append\_mode: bool}
\sphinxAtStartPar
If true the ensemble is appended

\end{description}
\end{quote}

\end{fulllineitems}

\index{save\_raw() (sscha.Ensemble.Ensemble method)@\spxentry{save\_raw()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.save_raw}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save\_raw}}}{\emph{\DUrole{n}{root\_directory}}, \emph{\DUrole{n}{type\_dict}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Save the ensemble as a set of raw files.

\sphinxAtStartPar
This is the default format for training with deepmd


\subsection{Parameters}
\label{\detokenize{apireference:id25}}\begin{quote}
\begin{description}
\sphinxlineitem{filename}{[}string{]}
\sphinxAtStartPar
The directory on which to save the ensemble. If it does not exist, it is create.
NOTE: this will overwrite any other ensemble saved in raw format in that directory

\sphinxlineitem{type\_dict}{[}dict{]}
\sphinxAtStartPar
The dictionary between integers and atomic types. If not provided, it is generated on the spot and returned.

\end{description}
\end{quote}


\subsection{Returns}
\label{\detokenize{apireference:id26}}\begin{quote}
\begin{description}
\sphinxlineitem{type\_dict}{[}dict{]}
\sphinxAtStartPar
The dictionary of the parameters

\end{description}
\end{quote}

\end{fulllineitems}

\index{split() (sscha.Ensemble.Ensemble method)@\spxentry{split()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.split}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{split}}}{\emph{\DUrole{n}{split\_mask}}}{}
\pysigstopsignatures

\subsection{SPLIT THE ENSEMBLE}
\label{\detokenize{apireference:split-the-ensemble}}
\sphinxAtStartPar
This method will return an ensemble with only the configurations matched by the split\_mask array.
NOTE: The original ensemble will remain untouched.


\subsubsection{Parameters}
\label{\detokenize{apireference:id27}}\begin{quote}
\begin{description}
\sphinxlineitem{split\_mask}{[}ndarray(size = self.N, dtype = bool){]}
\sphinxAtStartPar
A mask array. It must be of the same size of the number of configurations,
and contain a True or False if you want that the corresponding configuration to be included in the
splitted ensemble

\end{description}
\end{quote}


\subsubsection{Results}
\label{\detokenize{apireference:id28}}\begin{quote}
\begin{description}
\sphinxlineitem{splitted\_ensemble}{[}Ensemble(){]}
\sphinxAtStartPar
An ensemble tath will contain only the configurations in the split mask.

\end{description}
\end{quote}

\end{fulllineitems}

\index{update\_weights() (sscha.Ensemble.Ensemble method)@\spxentry{update\_weights()}\spxextra{sscha.Ensemble.Ensemble method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Ensemble.Ensemble.update_weights}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_weights}}}{\emph{\DUrole{n}{new\_dynamical\_matrix}}, \emph{\DUrole{n}{newT}}, \emph{\DUrole{n}{update\_q}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{IMPORTANCE SAMPLING}
\label{\detokenize{apireference:importance-sampling}}
\sphinxAtStartPar
This function updates the importance sampling for the given dynamical matrix.
The result is written in the self.rho variable


\subsubsection{Parameters}
\label{\detokenize{apireference:id29}}\begin{quote}
\begin{description}
\sphinxlineitem{new\_dynamical\_matrix}{[}CC.Phonons.Phonons(){]}
\sphinxAtStartPar
The new dynamical matrix on which you want to compute the averages.

\sphinxlineitem{new\_T}{[}float{]}
\sphinxAtStartPar
The new temperature.

\sphinxlineitem{update\_q}{[}bool{]}
\sphinxAtStartPar
If false the q\_vectors are not updated. This is required for some
methods and application, but not for standard minimization.
Since it is the most time consuming part, it can be safely avoided.

\end{description}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{The SchaMinimizer Module}
\label{\detokenize{apireference:the-schaminimizer-module}}
\sphinxAtStartPar
This module is the main SSCHA minimizer. It allows us to set up a single (one population) minimization.
In this module, the minimization algorithm is introduced, as well as stopping conditions and all the parameters
usually located in the \&inputscha name list are read.
\index{SSCHA\_Minimizer (class in sscha.SchaMinimizer)@\spxentry{SSCHA\_Minimizer}\spxextra{class in sscha.SchaMinimizer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{sscha.SchaMinimizer.}}\sphinxbfcode{\sphinxupquote{SSCHA\_Minimizer}}}{\emph{\DUrole{n}{ensemble}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{root\_representation}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}normal\textquotesingle{}}}, \emph{\DUrole{n}{kong\_liu\_ratio}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{meaningful\_factor}\DUrole{o}{=}\DUrole{default_value}{0.2}}, \emph{\DUrole{n}{minimization\_algorithm}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}sdes\textquotesingle{}}}, \emph{\DUrole{n}{lambda\_a}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures\index{check\_imaginary\_frequencies() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{check\_imaginary\_frequencies()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.check_imaginary_frequencies}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_imaginary\_frequencies}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
The following subroutine check if the current matrix has imaginary frequency. In this case
the minimization is stopped.

\end{fulllineitems}

\index{check\_stop() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{check\_stop()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.check_stop}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_stop}}}{}{}
\pysigstopsignatures

\subsection{CHECK THE STOPPING CONDITION}
\label{\detokenize{apireference:check-the-stopping-condition}}
\sphinxAtStartPar
Check the stopping criteria and returns True if the stopping
condition is satisfied


\subsubsection{Result}
\label{\detokenize{apireference:result}}\begin{quote}
\begin{description}
\sphinxlineitem{bool :}
\sphinxAtStartPar
True if the minimization must be stopped, False otherwise

\end{description}
\end{quote}

\end{fulllineitems}

\index{finalize() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{finalize()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.finalize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{finalize}}}{\emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
\pysigstopsignatures

\subsection{FINALIZE}
\label{\detokenize{apireference:finalize}}
\sphinxAtStartPar
This method finalizes the minimization, and prints on stdout the
results of the current minimization.


\subsubsection{Parameters}
\label{\detokenize{apireference:id30}}\begin{quote}
\begin{description}
\sphinxlineitem{verbose}{[}int, optional{]}
\sphinxAtStartPar
The verbosity level. If 0 only the final free energy and gradient is printed.
If 1 the stress tensor is also printed. If 2 also the final structure and frequencies
are printed.

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_free\_energy() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{get\_free\_energy()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.get_free_energy}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_free\_energy}}}{\emph{\DUrole{n}{return\_error}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{SSCHA FREE ENERGY}
\label{\detokenize{apireference:id31}}
\sphinxAtStartPar
Obtain the SSCHA free energy per unit cell for the system. This is done through thermodynamic integration.
Note that for the SSCHA this integration is performed analytically, so evaluating this function
is almost immediate.

\sphinxAtStartPar
The result is in Rydberg.
\begin{equation*}
\begin{split}\mathcal F = \mathcal F_0 + \int_0^1 \frac{d\mathcal F_\lambda}{d\lambda} d\lambda\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\lambda\) is the parameter for the adiabatic integration of the hamiltonian.
\begin{equation*}
\begin{split}H(\lambda) = H_0 + (H - H_0) \lambda\end{split}
\end{equation*}
\sphinxAtStartPar
here \(H_0\) is the sscha harmonic hamiltonian, while \(H_1\) is the real hamiltonian
of the system.


\subsubsection{Returns}
\label{\detokenize{apireference:id32}}\begin{quote}
\begin{description}
\sphinxlineitem{float}
\sphinxAtStartPar
The free energy in the current dynamical matrix and at the ensemble temperature

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_stress\_tensor() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{get\_stress\_tensor()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.get_stress_tensor}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_stress\_tensor}}}{}{}
\pysigstopsignatures

\subsection{GET THE STRESS TENSOR}
\label{\detokenize{apireference:get-the-stress-tensor}}
\sphinxAtStartPar
For a full documentation, please refer to the same function of the
Ensemble class.
This subroutine just link to that one. A stress offset is added if defined
in the input variable of the current class.

\sphinxAtStartPar
NOTE: if the ensemble has not the stress tensors, an exception will be raised

\end{fulllineitems}

\index{init() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{init()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.init}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init}}}{\emph{\DUrole{n}{verbosity}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{delete\_previous\_data}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures

\subsection{INITIALIZE THE MINIMIZATION}
\label{\detokenize{apireference:initialize-the-minimization}}
\sphinxAtStartPar
This subroutine initialize the variables needed by the minimization.
Call this before the first time you invoke the run function.


\subsubsection{Parameters}
\label{\detokenize{apireference:id33}}\begin{quote}
\begin{description}
\sphinxlineitem{verbosity}{[}bool{]}
\sphinxAtStartPar
If true prints some debugging information

\sphinxlineitem{delete\_previous\_data}{[}bool{]}
\sphinxAtStartPar
If true, it will clean previous minimizations from the free energies, gradients…

\end{description}
\end{quote}

\end{fulllineitems}

\index{is\_converged() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{is\_converged()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.is_converged}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_converged}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Simple method to check if the simulation is converged or
requires a new population to be runned.


\subsection{Result}
\label{\detokenize{apireference:id34}}\begin{quote}
\begin{description}
\sphinxlineitem{bool :}
\sphinxAtStartPar
True if the simulation ended for converging.

\end{description}
\end{quote}

\end{fulllineitems}

\index{minimization\_step() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{minimization\_step()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.minimization_step}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{minimization\_step}}}{\emph{\DUrole{n}{custom\_function\_gradient}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Perform the single minimization step.
This modify the self.dyn matrix and updates the ensemble


\subsection{Parameters}
\label{\detokenize{apireference:id35}}\begin{quote}
\begin{description}
\sphinxlineitem{custom\_function\_gradient}{[}pointer to function ( ndarray(nq x 3nat x 3nat), ndarray(nat, 3)){]}
\sphinxAtStartPar
A function that can be used both to print particular component of the gradient
or to impose some constraints on the minimization (like lock the position of some atoms).
It takes as input the two gradient (the dynamical matrix one and the structure one), and
modifies them (or does some I/O on it).

\end{description}
\end{quote}

\end{fulllineitems}

\index{plot\_results() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{plot\_results()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.plot_results}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_results}}}{\emph{\DUrole{n}{save\_filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures

\subsection{PLOT RESULTS}
\label{\detokenize{apireference:plot-results}}
\sphinxAtStartPar
This usefull methods uses matplotlib to generate a plot of the
minimization.


\subsubsection{Parameters}
\label{\detokenize{apireference:id36}}\begin{quote}
\begin{description}
\sphinxlineitem{save\_filename}{[}optional, string{]}
\sphinxAtStartPar
If present the plotted data will be saved in
a text file specified by input.

\sphinxlineitem{plot}{[}optiona, bool{]}
\sphinxAtStartPar
If false no plot is performed. This allows only to save result
even if you do not have any access in a X server.

\end{description}
\end{quote}

\end{fulllineitems}

\index{print\_info() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{print\_info()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.print_info}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{print\_info}}}{}{}
\pysigstopsignatures

\subsection{PRINT SETTINGS ON OUTPUT}
\label{\detokenize{apireference:print-settings-on-output}}
\sphinxAtStartPar
This subroutine is for debugging purposes, it will print the settings about
the minimizer on the standard output.

\end{fulllineitems}

\index{run() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{run()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.run}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{custom\_function\_pre}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{custom\_function\_post}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{custom\_function\_gradient}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures

\subsection{RUN THE SSCHA MINIMIZATION}
\label{\detokenize{apireference:run-the-sscha-minimization}}
\sphinxAtStartPar
This function uses all the setted up parameters to run the minimization

\sphinxAtStartPar
The minimization is stopped only when one of the stopping criteria are met.

\sphinxAtStartPar
The verbose level can be chosen.


\subsubsection{Parameters}
\label{\detokenize{apireference:id37}}\begin{quote}
\begin{description}
\sphinxlineitem{verbose}{[}int{]}\begin{description}
\sphinxlineitem{The verbosity level.}\begin{itemize}
\item {} 
\sphinxAtStartPar
0 : Noting is printed

\item {} \begin{description}
\sphinxlineitem{1}{[}For each step only the free energy, the modulus of the gradient and{]}
\sphinxAtStartPar
the Kong\sphinxhyphen{}Liu effective sample size is printed.

\end{description}

\item {} 
\sphinxAtStartPar
2 : The dynamical matrix at each step is saved on output with a progressive integer

\end{itemize}

\end{description}

\sphinxlineitem{custom\_function\_pre}{[}pointer to function (self){]}
\sphinxAtStartPar
It is a custom function that takes as an input the current
structure. At each step this function is invoked. This allows
to print particular analysis during the minimization that
the user want to define to better control what is it happening
to the system.
This function is called before the minimization step has been performed.
The info on the system saved in the self minimization reguards the previous step.

\sphinxlineitem{custom\_function\_post}{[}pointer to function(self){]}
\sphinxAtStartPar
The same as the previous argument, but this function is invoked after
the minimization step has been perfomed. The data about free energy,
gradient and effective sample size have been updated.

\sphinxlineitem{custom\_function\_gradient}{[}pointer to function (ndarray(NQ, 3*nat, 3*nat), ndarray(nat, 3)){]}
\sphinxAtStartPar
A pointer to a function that takes as an input the two gradients, and modifies them.
It is called after the two gradients have been computed, and it is used to
impose some constraint on the minimization.

\end{description}
\end{quote}

\end{fulllineitems}

\index{set\_ensemble() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{set\_ensemble()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.set_ensemble}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_ensemble}}}{\emph{\DUrole{n}{ensemble}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provide an ensemble to the minimizer object

\end{fulllineitems}

\index{set\_minimization\_step() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{set\_minimization\_step()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.set_minimization_step}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_minimization\_step}}}{\emph{\DUrole{n}{step}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Set an uniform minimization step for both the dynamical matrix and the structure minimization.

\sphinxAtStartPar
Try to always use this function unless you specifically want two difference speed between the structure and the dynamical matrix minimization.

\end{fulllineitems}

\index{setup\_from\_namelist() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{setup\_from\_namelist()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.setup_from_namelist}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup\_from\_namelist}}}{\emph{\DUrole{n}{input\_file}}}{}
\pysigstopsignatures

\subsection{SETUP THE MINIMIZATION}
\label{\detokenize{apireference:setup-the-minimization}}
\sphinxAtStartPar
This function setups all the parameters of the minimization using a namelist.
It is compatible with the old sscha code, and very usefull to save the
input parameters in a simple input filename.


\subsubsection{Parameters}
\label{\detokenize{apireference:id38}}\begin{quote}
\begin{description}
\sphinxlineitem{line\_list}{[}list of string{]}
\sphinxAtStartPar
List of strings obtained from the method readlines.
The content must match the Quantum ESPRESSO file format

\end{description}
\end{quote}

\end{fulllineitems}

\index{update() (sscha.SchaMinimizer.SSCHA\_Minimizer method)@\spxentry{update()}\spxextra{sscha.SchaMinimizer.SSCHA\_Minimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.SchaMinimizer.SSCHA_Minimizer.update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{}{}
\pysigstopsignatures

\subsection{UPDATE IMPORTANCE SAMPLING}
\label{\detokenize{apireference:update-importance-sampling}}
\sphinxAtStartPar
This methods makes the self.dyn coincide with self.ensemble.current\_dyn, and overwrites the stochastic
weights of the current\_dyn.

\sphinxAtStartPar
Call this method each time you modify the dynamical matrix of the minimization to avoid errors.

\sphinxAtStartPar
NOTE: it is equivalent to call self.ensemble.update\_weights(self.dyn, self.ensemble.current\_T)

\end{fulllineitems}


\end{fulllineitems}



\section{The Relax Module}
\label{\detokenize{apireference:the-relax-module}}
\sphinxAtStartPar
This module deals with relaxations that are iterated over more populations. It includes the variable cell optimization algorithm.
Here the parameters read in the \&relax name list are read and setup.
\index{SSCHA (class in sscha.Relax)@\spxentry{SSCHA}\spxextra{class in sscha.Relax}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Relax.SSCHA}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{sscha.Relax.}}\sphinxbfcode{\sphinxupquote{SSCHA}}}{\emph{\DUrole{n}{minimizer}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ase\_calculator}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{N\_configs}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{max\_pop}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{save\_ensemble}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cluster}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures\index{relax() (sscha.Relax.SSCHA method)@\spxentry{relax()}\spxextra{sscha.Relax.SSCHA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Relax.SSCHA.relax}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{relax}}}{\emph{\DUrole{n}{restart\_from\_ens}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{get\_stress}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{ensemble\_loc}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{start\_pop}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{sobol}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sobol\_scramble}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sobol\_scatter}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\pysigstopsignatures

\subsection{COSTANT VOLUME RELAX}
\label{\detokenize{apireference:costant-volume-relax}}
\sphinxAtStartPar
This function performs the costant volume SCHA relaxation, by submitting several populations
until the minimization converges (or the maximum number of population is reached)


\subsubsection{Parameters}
\label{\detokenize{apireference:id39}}\begin{quote}
\begin{description}
\sphinxlineitem{restart\_from\_ens}{[}bool, optional{]}
\sphinxAtStartPar
If True the ensemble is used to start the first population, without recomputing
energies and forces. If False (default) the first ensemble is overwritten with
a new one, and the minimization starts.

\sphinxlineitem{get\_stress}{[}bool, optional{]}
\sphinxAtStartPar
If true the stress tensor is calculated. This may increase the computational
cost, as it will be computed for each ab\sphinxhyphen{}initio configuration (it may be not available
with some ase calculator)

\sphinxlineitem{ensemble\_loc}{[}string{]}
\sphinxAtStartPar
Where the ensemble of each population is saved on the disk. If none, it will
use the content of self.data\_dir. It is just a way to override the variable self.data\_dir

\sphinxlineitem{start\_pop}{[}int, optional{]}
\sphinxAtStartPar
The starting index for the population, used only for saving the ensemble and the dynamical
matrix. If None, the content of self.start\_pop will be used.

\sphinxlineitem{sobol}{[}bool, optional (Default = False){]}
\sphinxAtStartPar
Defines if the calculation uses random Gaussian generator or Sobol Gaussian generator.

\sphinxlineitem{sobol\_scramble}{[}bool, optional (Default = False){]}
\sphinxAtStartPar
Set the optional scrambling of the generated numbers taken from the Sobol sequence.

\sphinxlineitem{sobol\_scatter}{[}real (0.0 to 1) (Deafault = 0.0){]}
\sphinxAtStartPar
Set the scatter parameter to displace the Sobol positions randommly.

\end{description}
\end{quote}


\subsubsection{Returns}
\label{\detokenize{apireference:id40}}\begin{quote}
\begin{description}
\sphinxlineitem{status}{[}bool{]}
\sphinxAtStartPar
True if the minimization converged, False if the maximum number of
populations has been reached.

\end{description}
\end{quote}

\end{fulllineitems}

\index{setup\_custom\_functions() (sscha.Relax.SSCHA method)@\spxentry{setup\_custom\_functions()}\spxextra{sscha.Relax.SSCHA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Relax.SSCHA.setup_custom_functions}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup\_custom\_functions}}}{\emph{\DUrole{n}{custom\_function\_pre}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{custom\_function\_gradient}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{custom\_function\_post}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This subroutine setup which custom functions should be called during the minimization.
Look for the SCHA\_Minimizer.run() method for other details.

\end{fulllineitems}

\index{setup\_from\_namelist() (sscha.Relax.SSCHA method)@\spxentry{setup\_from\_namelist()}\spxextra{sscha.Relax.SSCHA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Relax.SSCHA.setup_from_namelist}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup\_from\_namelist}}}{\emph{\DUrole{n}{namelist}}}{}
\pysigstopsignatures

\subsection{SETUP THE RELAXER FROM THE NAMELIST}
\label{\detokenize{apireference:setup-the-relaxer-from-the-namelist}}
\sphinxAtStartPar
Setup the SSCHA relaxer from the given namelist.

\sphinxAtStartPar
Note the calculation will be also started by this method.


\subsubsection{Parameters}
\label{\detokenize{apireference:id41}}\begin{quote}
\begin{description}
\sphinxlineitem{namelist}{[}dict{]}
\sphinxAtStartPar
A dictionary that contains the namespaces

\end{description}
\end{quote}

\end{fulllineitems}

\index{vc\_relax() (sscha.Relax.SSCHA method)@\spxentry{vc\_relax()}\spxextra{sscha.Relax.SSCHA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Relax.SSCHA.vc_relax}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{vc\_relax}}}{\emph{\DUrole{n}{target\_press}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{static\_bulk\_modulus}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{restart\_from\_ens}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{ensemble\_loc}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{start\_pop}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{stress\_numerical}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cell\_relax\_algorithm}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}sd\textquotesingle{}}}, \emph{\DUrole{n}{fix\_volume}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sobol}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sobol\_scramble}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sobol\_scatter}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\pysigstopsignatures

\subsection{VARIABLE CELL RELAX}
\label{\detokenize{apireference:variable-cell-relax}}
\sphinxAtStartPar
This function performs a variable cell SCHA relaxation at constant pressure,
It is similar to the relax calculation, but the unit cell is updated according
to the anharmonic stress tensor at each new population.

\sphinxAtStartPar
By default, all the degrees of freedom compatible with the symmetry group are relaxed in the cell.
You can constrain the cell to keep the same shape by setting fix\_cell\_shape = True.
\begin{description}
\sphinxlineitem{NOTE:}
\sphinxAtStartPar
remember to setup the stress\_offset variable of the SCHA\_Minimizer,
because in ab\sphinxhyphen{}initio calculation the stress tensor converges porly with the cutoff,
but stress tensor differences converges much quicker. Therefore, setup the
stress tensor difference between a single very high\sphinxhyphen{}cutoff calculation and a
single low\sphinxhyphen{}cutoff (the one you use), this difference will be added at the final
stress tensor to get a better estimation of the true stress.

\end{description}


\subsubsection{Parameters}
\label{\detokenize{apireference:id42}}\begin{quote}
\begin{description}
\sphinxlineitem{target\_press}{[}float, optional{]}
\sphinxAtStartPar
The target pressure of the minimization (in GPa). The minimization is stopped if the
target pressure is the stress tensor is the identity matrix multiplied by the
target pressure, with a tollerance equal to the stochastic noise. By default
it is 0 (ambient pressure)

\sphinxlineitem{static\_bulk\_modulus}{[}float (default 100), or (9x9) matrix or string, optional{]}
\sphinxAtStartPar
The static bulk modulus, expressed in GPa. It is used to initialize the
hessian matrix on the BFGS cell relaxation, to guess the volume deformation caused
by the anharmonic stress tensor in the first steps. By default is 100 GPa (higher value
are safer, since they means a lower change in the cell shape).
It can be also the whole non isotropic matrix. If you specify a string, it
can be both:
\begin{itemize}
\item {} \begin{description}
\sphinxlineitem{“recalc”}{[}the static bulk modulus is recomputed with finite differences after{]}
\sphinxAtStartPar
each step

\end{description}

\item {} 
\sphinxAtStartPar
“bfgs” : the bfgs algorithm is used to infer the Hessian from previous calculations.

\end{itemize}

\sphinxlineitem{restart\_from\_ens}{[}bool, optional{]}
\sphinxAtStartPar
If True the ensemble is used to start the first population, without recomputing
energies and forces. If False (default) the first ensemble is overwritten with
a new one, and the minimization starts.

\sphinxlineitem{ensemble\_loc}{[}string{]}
\sphinxAtStartPar
Where the ensemble of each population is saved on the disk. You can specify None
if you do not want to save the ensemble (useful to avoid disk I/O for force fields)

\sphinxlineitem{start\_pop}{[}int, optional{]}
\sphinxAtStartPar
The starting index for the population, used only for saving the ensemble and the dynamical
matrix.

\sphinxlineitem{stress\_numerical}{[}bool{]}
\sphinxAtStartPar
If True the stress is computed by finite difference (usefull for calculators that
does not support it by default)

\sphinxlineitem{cell\_relax\_algorithm}{[}string{]}
\sphinxAtStartPar
This identifies the stress algorithm. It can be both sd (steepest\sphinxhyphen{}descent),
cg (conjugate\sphinxhyphen{}gradient) or bfgs (Quasi\sphinxhyphen{}newton).
The most robust one is SD. Do not change if you are not sure what you are doing.

\sphinxlineitem{fix\_volume}{[}bool, optional{]}
\sphinxAtStartPar
If true (default False) the volume is fixed, therefore only the cell shape is relaxed.

\sphinxlineitem{sobol}{[}bool, optional (Default = False){]}
\sphinxAtStartPar
Defines if the calculation uses random Gaussian generator or Sobol Gaussian generator.

\sphinxlineitem{sobol\_scramble}{[}bool, optional (Default = False){]}
\sphinxAtStartPar
Set the optional scrambling of the generated numbers taken from the Sobol sequence.

\sphinxlineitem{sobol\_scatter}{[}real (0.0 to 1) (Deafault = 0.0){]}
\sphinxAtStartPar
Set the scatter parameter to displace the Sobol positions randommly.

\end{description}
\end{quote}


\subsubsection{Returns}
\label{\detokenize{apireference:id43}}\begin{quote}
\begin{description}
\sphinxlineitem{status}{[}bool{]}
\sphinxAtStartPar
True if the minimization converged, False if the maximum number of
populations has been reached.

\end{description}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{The Utilities Module}
\label{\detokenize{apireference:the-utilities-module}}
\sphinxAtStartPar
This module both provides the constrains and the IOinput


\subsection{IOInfo class}
\label{\detokenize{apireference:ioinfo-class}}
\sphinxAtStartPar
Use this class to make the python\sphinxhyphen{}sscha print information during the minimization
\index{IOInfo (class in sscha.Utilities)@\spxentry{IOInfo}\spxextra{class in sscha.Utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.IOInfo}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{sscha.Utilities.}}\sphinxbfcode{\sphinxupquote{IOInfo}}}
\pysigstopsignatures\index{CFP\_SaveAll() (sscha.Utilities.IOInfo method)@\spxentry{CFP\_SaveAll()}\spxextra{sscha.Utilities.IOInfo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.IOInfo.CFP_SaveAll}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{CFP\_SaveAll}}}{\emph{\DUrole{n}{minim}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method saves everithing stored in this class.

\sphinxAtStartPar
It can be passed as custom\_function\_post to the run method of the SchaMinimizer.

\end{fulllineitems}

\index{CFP\_SaveFrequencies() (sscha.Utilities.IOInfo method)@\spxentry{CFP\_SaveFrequencies()}\spxextra{sscha.Utilities.IOInfo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.IOInfo.CFP_SaveFrequencies}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{CFP\_SaveFrequencies}}}{\emph{\DUrole{n}{minim}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This custom method stores the total frequencies updating an exeternal file

\end{fulllineitems}

\index{Reset() (sscha.Utilities.IOInfo method)@\spxentry{Reset()}\spxextra{sscha.Utilities.IOInfo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.IOInfo.Reset}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Reset}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Reset the data to empty.

\end{fulllineitems}

\index{Save() (sscha.Utilities.IOInfo method)@\spxentry{Save()}\spxextra{sscha.Utilities.IOInfo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.IOInfo.Save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Save}}}{\emph{\DUrole{n}{fname}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Save the data on a file


\subsubsection{Parameters}
\label{\detokenize{apireference:id44}}\begin{quote}
\begin{description}
\sphinxlineitem{fname}{[}string, optional{]}
\sphinxAtStartPar
If given, the file will be saved in the specified location.
Otherwise the default one is used (must be initialized by SetupSaving)

\end{description}
\end{quote}

\end{fulllineitems}

\index{SetupAtomicPositions() (sscha.Utilities.IOInfo method)@\spxentry{SetupAtomicPositions()}\spxextra{sscha.Utilities.IOInfo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.IOInfo.SetupAtomicPositions}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetupAtomicPositions}}}{\emph{\DUrole{n}{fname}}, \emph{\DUrole{n}{save\_each\_step}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Setup the saving of the data on atomic position along with the minimization

\end{fulllineitems}

\index{SetupSaving() (sscha.Utilities.IOInfo method)@\spxentry{SetupSaving()}\spxextra{sscha.Utilities.IOInfo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.IOInfo.SetupSaving}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetupSaving}}}{\emph{\DUrole{n}{fname}}, \emph{\DUrole{n}{save\_each\_step}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Setup the system to save the data each time the function is called.

\sphinxAtStartPar
By default, the system will save frequencies and minimization info (like free energy, gradients and kong liu)
The files are
.freqs   for the frequencies
.dat     for the minimization info


\subsubsection{Parameters}
\label{\detokenize{apireference:id45}}\begin{quote}
\begin{description}
\sphinxlineitem{fname}{[}string {]}
\sphinxAtStartPar
path to the file to save the files

\sphinxlineitem{save\_each\_step}{[}bool{]}
\sphinxAtStartPar
If true the file is saved (and updated) each time step.

\end{description}
\end{quote}

\end{fulllineitems}

\index{SetupWeights() (sscha.Utilities.IOInfo method)@\spxentry{SetupWeights()}\spxextra{sscha.Utilities.IOInfo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.IOInfo.SetupWeights}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetupWeights}}}{\emph{\DUrole{n}{fname}}, \emph{\DUrole{n}{save\_each\_step}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Setup the weights saving


\subsubsection{Parameters}
\label{\detokenize{apireference:id46}}\begin{quote}
\begin{description}
\sphinxlineitem{fname}{[}string{]}
\sphinxAtStartPar
Path to the file to which save the frequencies.

\end{description}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Constraints}
\label{\detokenize{apireference:constraints}}
\sphinxAtStartPar
The constrains are a member of the Utilities module.
To implement constrains on phonon modes, use the ModeProjection class
\index{ModeProjection (class in sscha.Utilities)@\spxentry{ModeProjection}\spxextra{class in sscha.Utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.ModeProjection}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{sscha.Utilities.}}\sphinxbfcode{\sphinxupquote{ModeProjection}}}{\emph{\DUrole{n}{dyn}}}{}
\pysigstopsignatures\index{CFG\_ProjectDyn() (sscha.Utilities.ModeProjection method)@\spxentry{CFG\_ProjectDyn()}\spxextra{sscha.Utilities.ModeProjection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.ModeProjection.CFG_ProjectDyn}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{CFG\_ProjectDyn}}}{\emph{\DUrole{n}{dyn\_grad}}, \emph{\DUrole{n}{struct\_grad}}}{}
\pysigstopsignatures

\subsubsection{PROJECT ONLY THE FC GRADIENT IN THE SELECTED MODES}
\label{\detokenize{apireference:project-only-the-fc-gradient-in-the-selected-modes}}
\sphinxAtStartPar
This subroutine constrains only the dynamical matrix, leaving the structure
to minimize on all the possible degrees of freedom.

\end{fulllineitems}

\index{CFG\_ProjectOnModes() (sscha.Utilities.ModeProjection method)@\spxentry{CFG\_ProjectOnModes()}\spxextra{sscha.Utilities.ModeProjection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.ModeProjection.CFG_ProjectOnModes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{CFG\_ProjectOnModes}}}{\emph{\DUrole{n}{dyn\_grad}}, \emph{\DUrole{n}{struct\_grad}}}{}
\pysigstopsignatures

\subsubsection{PROJECT THE GRADIENT IN THE SELECTED MODES}
\label{\detokenize{apireference:project-the-gradient-in-the-selected-modes}}
\sphinxAtStartPar
Function to be passed to the minimizer as ‘custom\_function\_gradient’. 
It project the gradients in the polarization vector subspace.
As any custom\_function\_gradient, it takes as input the two gradients.

\end{fulllineitems}

\index{CFG\_ProjectStructure() (sscha.Utilities.ModeProjection method)@\spxentry{CFG\_ProjectStructure()}\spxextra{sscha.Utilities.ModeProjection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.ModeProjection.CFG_ProjectStructure}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{CFG\_ProjectStructure}}}{\emph{\DUrole{n}{dyn\_grad}}, \emph{\DUrole{n}{struct\_grad}}}{}
\pysigstopsignatures

\subsubsection{PROJECT ONLY THE STRUCTURE GRADIENT IN THE SELECTED MODES}
\label{\detokenize{apireference:project-only-the-structure-gradient-in-the-selected-modes}}
\sphinxAtStartPar
This subroutine constraints only the structure gradient, leaving the
dynamical matrix to minimize on all the possible degrees of freedom.

\end{fulllineitems}

\index{SetupFreeModes() (sscha.Utilities.ModeProjection method)@\spxentry{SetupFreeModes()}\spxextra{sscha.Utilities.ModeProjection method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Utilities.ModeProjection.SetupFreeModes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetupFreeModes}}}{\emph{\DUrole{n}{index\_mode\_start}}, \emph{\DUrole{n}{index\_mode\_end}}, \emph{\DUrole{n}{select\_q\_points}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{constrain}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsubsection{SETUP FREE (or constrained) MODES}
\label{\detokenize{apireference:setup-free-or-constrained-modes}}
\sphinxAtStartPar
Constrain the minimization only in the modes between index\_modes\_start and
index\_mdoe\_end in all the q points. Also the opposite is possible, 
by setting the constrain flag to True.

\sphinxAtStartPar
For each q points only modes between these indices will be minimized.
The select\_q\_points options allows to select only some q points to be constrained.


\paragraph{Parameters}
\label{\detokenize{apireference:id47}}\begin{quote}
\begin{description}
\sphinxlineitem{index\_mode\_start}{[}int{]}
\sphinxAtStartPar
The index of the first mode

\sphinxlineitem{index\_mode\_end}{[}int{]}
\sphinxAtStartPar
The index of the last mode

\sphinxlineitem{select\_q\_points}{[}list of int{]}
\sphinxAtStartPar
The index of the q points affected. 
If None (default) all q points are affected.

\sphinxlineitem{constrain}{[}bool{]}
\sphinxAtStartPar
If True, the specified range of modes is constrained while all the other are free.

\end{description}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{The Cluster Module}
\label{\detokenize{apireference:the-cluster-module}}
\sphinxAtStartPar
The Cluster module provides the interface between python\sphinxhyphen{}sscha and remote servers to which you submit the energy and forces calculations.
The input in \&cluster namespace is interpreted in this module
\index{Cluster (class in sscha.Cluster)@\spxentry{Cluster}\spxextra{class in sscha.Cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{sscha.Cluster.}}\sphinxbfcode{\sphinxupquote{Cluster}}}{\emph{\DUrole{n}{hostname}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{pwd}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{extra\_options}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{workdir}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{account\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{partition\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{binary}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}pw.x \sphinxhyphen{}npool NPOOL \sphinxhyphen{}i PREFIX.pwi \textgreater{} PREFIX.pwo\textquotesingle{}}}, \emph{\DUrole{n}{mpi\_cmd}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}srun \sphinxhyphen{}\sphinxhyphen{}mpi=pmi2 \sphinxhyphen{}n NPROC\textquotesingle{}}}}{}
\pysigstopsignatures\index{CheckCommunication() (sscha.Cluster.Cluster method)@\spxentry{CheckCommunication()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.CheckCommunication}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{CheckCommunication}}}{}{}
\pysigstopsignatures

\subsection{CHECK IF THE SERVER IS AVAILABLE}
\label{\detokenize{apireference:check-if-the-server-is-available}}
\sphinxAtStartPar
This function return true if the server respond correctly, 
false otherwise.

\end{fulllineitems}

\index{ExecuteCMD() (sscha.Cluster.Cluster method)@\spxentry{ExecuteCMD()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.ExecuteCMD}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ExecuteCMD}}}{\emph{\DUrole{n}{cmd}}, \emph{\DUrole{n}{raise\_error}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{return\_output}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{on\_cluster}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures

\subsection{EXECUTE THE CMD ON THE CLUSTER}
\label{\detokenize{apireference:execute-the-cmd-on-the-cluster}}
\sphinxAtStartPar
This subroutine execute the cmd in the cluster,
with the specified number of attempts.


\subsubsection{Parameters}
\label{\detokenize{apireference:id48}}\begin{quote}
\begin{description}
\sphinxlineitem{cmd: string}
\sphinxAtStartPar
The whole command, including the ssh/scp.

\sphinxlineitem{raise\_error}{[}bool, optional{]}
\sphinxAtStartPar
If True (default) raises an error upon failure.

\sphinxlineitem{return\_output}{[}bool, optional{]}
\sphinxAtStartPar
If True (default False) the output of the command is 
returned as second value.

\sphinxlineitem{on\_cluster}{[}bool{]}
\sphinxAtStartPar
If true, the command is executed directly on the cluster through ssh

\end{description}
\end{quote}


\subsubsection{Returns}
\label{\detokenize{apireference:id49}}\begin{quote}
\begin{description}
\sphinxlineitem{success}{[}bool{]}
\sphinxAtStartPar
If True, the command has been executed with success,
False otherwise

\sphinxlineitem{output}{[}string{]}
\sphinxAtStartPar
Returned only if return\_output is True

\end{description}
\end{quote}

\end{fulllineitems}

\index{batch\_submission() (sscha.Cluster.Cluster method)@\spxentry{batch\_submission()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.batch_submission}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{batch\_submission}}}{\emph{\DUrole{n}{list\_of\_structures}}, \emph{\DUrole{n}{calc}}, \emph{\DUrole{n}{indices}}, \emph{\DUrole{n}{in\_extension}}, \emph{\DUrole{n}{out\_extension}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}ESP\textquotesingle{}}}, \emph{\DUrole{n}{n\_togheder}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
\pysigstopsignatures

\subsection{BATCH SUBMISSION}
\label{\detokenize{apireference:batch-submission}}
\sphinxAtStartPar
This is a different kind of submission, it exploits xargs to perform
a parallel submission of serveral structures in one single job.
This is very good to avoid overloading the queue system manager, or
when a limited number of jobs per user are allowed.

\sphinxAtStartPar
NOTE: the number of structure in the list must be a divisor of the
total number of processors.


\subsubsection{Parameters}
\label{\detokenize{apireference:id50}}\begin{quote}
\begin{description}
\sphinxlineitem{list\_of\_structures}{[}list{]}
\sphinxAtStartPar
List of the structures to be computed.

\sphinxlineitem{calc}{[}ase FileIOCalculator{]}
\sphinxAtStartPar
The FileIOCalculator to perform the minimization

\sphinxlineitem{indices}{[}list(int){]}
\sphinxAtStartPar
The indices of the configurations, this avoids interferring with
other jobs when multiple jobs are lunched togheder.

\sphinxlineitem{in\_extension}{[}string{]}
\sphinxAtStartPar
Extension of the input filename

\sphinxlineitem{out\_extension}{[}string{]}
\sphinxAtStartPar
Extension of the output filename.

\sphinxlineitem{label}{[}string, optional{]}
\sphinxAtStartPar
The root of the input file.

\sphinxlineitem{n\_togheder}{[}int, optional (DO NOT USE){]}
\sphinxAtStartPar
If present, the job will lunch a new job immediately after the other 
is ended. This is usefull to further reduce the number of submitted 
jobs.

\end{description}
\end{quote}


\subsubsection{Results}
\label{\detokenize{apireference:id51}}\begin{quote}
\begin{description}
\sphinxlineitem{list\_of\_results.}
\sphinxAtStartPar
Returns a list of results dicts, one for each structure.

\end{description}
\end{quote}

\end{fulllineitems}

\index{check\_job\_finished() (sscha.Cluster.Cluster method)@\spxentry{check\_job\_finished()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.check_job_finished}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_job\_finished}}}{\emph{\DUrole{n}{job\_id}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Check if the job identified by the job\_id is finished


\subsection{Parameters}
\label{\detokenize{apireference:id52}}\begin{quote}
\begin{description}
\sphinxlineitem{job\_id}{[}string{]}
\sphinxAtStartPar
The string that identifies uniquely the job

\end{description}
\end{quote}

\end{fulllineitems}

\index{clean\_localworkdir() (sscha.Cluster.Cluster method)@\spxentry{clean\_localworkdir()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.clean_localworkdir}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clean\_localworkdir}}}{}{}
\pysigstopsignatures

\subsection{CLEAN THE LOCAL WORKDIR FROM ALL INPUT/OUTPUT FILES IN TAR}
\label{\detokenize{apireference:clean-the-local-workdir-from-all-input-output-files-in-tar}}
\end{fulllineitems}

\index{collect\_results() (sscha.Cluster.Cluster method)@\spxentry{collect\_results()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.collect_results}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{collect\_results}}}{\emph{\DUrole{n}{calc}}, \emph{\DUrole{n}{submitted}}, \emph{\DUrole{n}{indices}}, \emph{\DUrole{n}{label}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Collect back all the results from the submitted data.
This operation needs to be performed in thread safe mode
(all threads must be locked between this operation and when the results are actually assigned to the ensemble
to avoid conflicts)

\end{fulllineitems}

\index{compute\_ensemble() (sscha.Cluster.Cluster method)@\spxentry{compute\_ensemble()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.compute_ensemble}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_ensemble}}}{\emph{\DUrole{n}{ensemble}}, \emph{\DUrole{n}{ase\_calc}}, \emph{\DUrole{n}{get\_stress}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{timeout}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures

\subsection{RUN THE WHOLE ENSEMBLE ON THE CLUSTER}
\label{\detokenize{apireference:run-the-whole-ensemble-on-the-cluster}}

\subsubsection{Parameters}
\label{\detokenize{apireference:id53}}\begin{quote}
\begin{description}
\sphinxlineitem{ensemble :}
\sphinxAtStartPar
The ensemble to be runned.

\end{description}
\end{quote}

\end{fulllineitems}

\index{compute\_ensemble\_batch() (sscha.Cluster.Cluster method)@\spxentry{compute\_ensemble\_batch()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.compute_ensemble_batch}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_ensemble\_batch}}}{\emph{\DUrole{n}{ensemble}}, \emph{\DUrole{n}{cellconstructor\_calc}}, \emph{\DUrole{n}{get\_stress}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{timeout}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures

\subsection{RUN THE ENSEMBLE WITH BATCH SUBMISSION}
\label{\detokenize{apireference:run-the-ensemble-with-batch-submission}}
\end{fulllineitems}

\index{copy\_files() (sscha.Cluster.Cluster method)@\spxentry{copy\_files()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.copy_files}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy\_files}}}{\emph{\DUrole{n}{list\_of\_input}}, \emph{\DUrole{n}{list\_of\_output}}, \emph{\DUrole{n}{to\_server}}}{}
\pysigstopsignatures

\subsection{COPY INPUT/OUTPUT FILES FROM/TO THE SERVER}
\label{\detokenize{apireference:copy-input-output-files-from-to-the-server}}
\sphinxAtStartPar
This function copies the input files toward the HPC if to\_server is True
or retrive the output files from the HPC if to\_server is False


\subsubsection{Parameters}
\label{\detokenize{apireference:id54}}\begin{quote}
\begin{description}
\sphinxlineitem{list\_of\_input}{[}list{]}
\sphinxAtStartPar
List of the path to the input files to be copied into the server.

\sphinxlineitem{list\_of\_output}{[}list{]}
\sphinxAtStartPar
List of the output files to be copied from the HPC server.
It is needed also when submitting the input file from the server,
as files that are named in the same way will be cleaned.
(No risk to mistake them with the actual result of the calculation)

\sphinxlineitem{to\_server}{[}bool{]}
\sphinxAtStartPar
If true, we copy the input files into the server from the local machine.
If false, we copy the output files from the server to the local machine.

\end{description}
\end{quote}

\end{fulllineitems}

\index{create\_submission\_script() (sscha.Cluster.Cluster method)@\spxentry{create\_submission\_script()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.create_submission_script}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_submission\_script}}}{\emph{\DUrole{n}{labels}}}{}
\pysigstopsignatures

\subsection{CREATE THE SUBMISSION SCRIPT}
\label{\detokenize{apireference:create-the-submission-script}}
\sphinxAtStartPar
This is a function that is general and does not depend on the specific
calculator. It is usefull to create the header of the submission script.


\subsubsection{Parameters}
\label{\detokenize{apireference:id55}}\begin{quote}
\begin{description}
\sphinxlineitem{labels}{[}list {]}
\sphinxAtStartPar
It is a list of the labels of the calculations to be done.

\end{description}
\end{quote}


\subsubsection{Returns}
\label{\detokenize{apireference:id56}}\begin{quote}
\begin{description}
\sphinxlineitem{submission\_header}{[}string{]}
\sphinxAtStartPar
The text of the submission header.

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_execution\_command() (sscha.Cluster.Cluster method)@\spxentry{get\_execution\_command()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.get_execution_command}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_execution\_command}}}{\emph{\DUrole{n}{label}}}{}
\pysigstopsignatures

\subsection{GET THE EXECUTION COMMAND}
\label{\detokenize{apireference:get-the-execution-command}}
\sphinxAtStartPar
Return the command used in the submission script to actually execute the calculation.


\subsubsection{Parameters}
\label{\detokenize{apireference:id57}}\begin{quote}
\begin{description}
\sphinxlineitem{label}{[}string{]}
\sphinxAtStartPar
The label of the calculation

\end{description}
\end{quote}


\subsubsection{Returns}
\label{\detokenize{apireference:id58}}\begin{quote}
\begin{description}
\sphinxlineitem{commnad}{[}string{]}
\sphinxAtStartPar
The command to be appended to the submission script

\end{description}
\end{quote}

\end{fulllineitems}

\index{get\_job\_id\_from\_submission\_output() (sscha.Cluster.Cluster method)@\spxentry{get\_job\_id\_from\_submission\_output()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.get_job_id_from_submission_output}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_job\_id\_from\_submission\_output}}}{\emph{\DUrole{n}{output}}}{}
\pysigstopsignatures
\sphinxAtStartPar
GET THE JOB ID

\sphinxAtStartPar
Retreive the job id from the output of the submission. 
This depends on the software employed. It works for slurm.

\sphinxAtStartPar
Returns None if the output contains an error

\end{fulllineitems}

\index{get\_output\_path() (sscha.Cluster.Cluster method)@\spxentry{get\_output\_path()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.get_output_path}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_output\_path}}}{\emph{\DUrole{n}{label}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Given the label of the submission, retrive the path of all the output files of that calculation

\end{fulllineitems}

\index{parse\_string() (sscha.Cluster.Cluster method)@\spxentry{parse\_string()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.parse_string}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parse\_string}}}{\emph{\DUrole{n}{string}}}{}
\pysigstopsignatures

\subsection{PARSE STRING}
\label{\detokenize{apireference:parse-string}}
\sphinxAtStartPar
Parse the given string on the cluster. 
It can be used to resolve environmental variables defined in the cluster.
\begin{description}
\sphinxlineitem{It will execute on the cluster the command:}
\sphinxAtStartPar
echo “string”

\end{description}

\sphinxAtStartPar
and return the result of the cluster.


\subsubsection{Parameter}
\label{\detokenize{apireference:parameter}}\begin{quote}
\begin{description}
\sphinxlineitem{string :}
\sphinxAtStartPar
String to be parsed in the cluster.

\end{description}
\end{quote}


\subsubsection{Result}
\label{\detokenize{apireference:id59}}\begin{quote}
\begin{description}
\sphinxlineitem{string :}
\sphinxAtStartPar
The same as input, but with the cluster environmental variables correctly
parsed.

\end{description}
\end{quote}

\end{fulllineitems}

\index{prepare\_input\_file() (sscha.Cluster.Cluster method)@\spxentry{prepare\_input\_file()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.prepare_input_file}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_input\_file}}}{\emph{\DUrole{n}{structures}}, \emph{\DUrole{n}{calc}}, \emph{\DUrole{n}{labels}}}{}
\pysigstopsignatures

\subsection{PREPARE THE INPUT FILE}
\label{\detokenize{apireference:prepare-the-input-file}}
\sphinxAtStartPar
This is specific for quantum espresso and must be inherit and replaced for 
other calculators.

\sphinxAtStartPar
This crates the input files in the local working directory 
self.local\_workdir and it returns the list of all the files generated.


\subsubsection{Parameters}
\label{\detokenize{apireference:id60}}\begin{quote}
\begin{description}
\sphinxlineitem{structures}{[}List of cellconstructor.Structure.Structure{]}
\sphinxAtStartPar
The atomic structures.

\sphinxlineitem{calc}{[}the ASE or CellConstructor calculator.{]}
\sphinxAtStartPar
In this case, it works with quantum espresso

\sphinxlineitem{labels}{[}List of strings{]}
\sphinxAtStartPar
The unique name of this calculation

\end{description}
\end{quote}


\subsubsection{Returns}
\label{\detokenize{apireference:id61}}\begin{quote}
\begin{description}
\sphinxlineitem{List\_of\_input}{[}list{]}
\sphinxAtStartPar
List of strings containing all the input files

\sphinxlineitem{List\_of\_output}{[}list{]}
\sphinxAtStartPar
List of strings containing the output files expected
for the calculation

\end{description}
\end{quote}

\end{fulllineitems}

\index{read\_results() (sscha.Cluster.Cluster method)@\spxentry{read\_results()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.read_results}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read\_results}}}{\emph{\DUrole{n}{calc}}, \emph{\DUrole{n}{label}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Return a dictionary of the computed property for the given calculation label

\end{fulllineitems}

\index{run\_atoms() (sscha.Cluster.Cluster method)@\spxentry{run\_atoms()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.run_atoms}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_atoms}}}{\emph{\DUrole{n}{ase\_calc}}, \emph{\DUrole{n}{ase\_atoms}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}ESP\textquotesingle{}}}, \emph{\DUrole{n}{in\_extension}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.pwi\textquotesingle{}}}, \emph{\DUrole{n}{out\_extension}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.pwo\textquotesingle{}}}, \emph{\DUrole{n}{n\_nodes}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{n\_cpu}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{npool}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
\pysigstopsignatures

\subsection{RUN ATOMS ON THE CLUSTER}
\label{\detokenize{apireference:run-atoms-on-the-cluster}}
\sphinxAtStartPar
This function runs the given atoms in the cluster, using the ase\_calculator.
Note: the ase\_calc must be a FileIOCalculator. 
For now it works with quantum espresso.

\end{fulllineitems}

\index{set\_timeout() (sscha.Cluster.Cluster method)@\spxentry{set\_timeout()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.set_timeout}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_timeout}}}{\emph{\DUrole{n}{timeout}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Set a timeout time for each single calculation.
This is very usefull as sometimes the calculations gets stucked after some times on clusters.


\subsection{Parameters}
\label{\detokenize{apireference:id62}}\begin{quote}
\begin{description}
\sphinxlineitem{timeout: int}
\sphinxAtStartPar
The timeout in seconds after which a single calculation is killed.

\end{description}
\end{quote}

\end{fulllineitems}

\index{setup\_from\_namelist() (sscha.Cluster.Cluster method)@\spxentry{setup\_from\_namelist()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.setup_from_namelist}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup\_from\_namelist}}}{\emph{\DUrole{n}{namelist}}}{}
\pysigstopsignatures

\subsection{SETUP THE CLUSTER WITH AN INPUTFILE}
\label{\detokenize{apireference:setup-the-cluster-with-an-inputfile}}
\sphinxAtStartPar
This method setup the cluster using a custom input file.
The inputfile must have the same shape of QuantumESPRESSO ones.
The information about the cluster must be located in a namespace called
as \_\_CLUSTER\_NAMELIST


\subsubsection{Parameters}
\label{\detokenize{apireference:id63}}\begin{quote}
\begin{description}
\sphinxlineitem{namelist: }
\sphinxAtStartPar
The parsed namelist dictionary.

\end{description}
\end{quote}

\end{fulllineitems}

\index{setup\_workdir() (sscha.Cluster.Cluster method)@\spxentry{setup\_workdir()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.setup_workdir}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup\_workdir}}}{\emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\pysigstopsignatures

\subsection{SETUP THE WORKING DIRECTORY}
\label{\detokenize{apireference:setup-the-working-directory}}
\sphinxAtStartPar
Parse the line contained in self.workdir in the claster to get working directory.
It needs that the communication with the cluster has been correctly setted up.

\sphinxAtStartPar
It will parse correctly environmental variables of the cluster.

\end{fulllineitems}

\index{submit() (sscha.Cluster.Cluster method)@\spxentry{submit()}\spxextra{sscha.Cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{apireference:sscha.Cluster.Cluster.submit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{submit}}}{\emph{\DUrole{n}{script\_location}}}{}
\pysigstopsignatures

\subsection{SUBMIT THE CALCULATION}
\label{\detokenize{apireference:submit-the-calculation}}
\sphinxAtStartPar
Submit the calculation. Compose the command into a cmd variable, then submit it through:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ExecuteCMD}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{return\PYGZus{}output}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Parameters}
\label{\detokenize{apireference:id64}}\begin{quote}
\begin{description}
\sphinxlineitem{script\_localtion}{[}string{]}
\sphinxAtStartPar
Path to the submission script inside the cluster.

\end{description}
\end{quote}


\subsubsection{Results}
\label{\detokenize{apireference:id65}}\begin{quote}
\begin{description}
\sphinxlineitem{success}{[}bool{]}
\sphinxAtStartPar
Result of the execution of the submission command. 
It is what returned from self.ExecuteCMD(cmd, False)

\end{description}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index1:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}