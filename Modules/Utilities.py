"""
This module contains the prefined custom function to
perform some standard variants of the minimization.

The function are classified as:
CGF : custom_gradient_function

"""

import numpy as np

class ModeProjection:
    def __init__(self, pols):
        """
        This class is used to project the gradient in or out of
        a space generated by the mode in the pols array.

        Parameters
        ----------
            pols : ndarray( 3*nat, nmodes, nq)
                The modes to be used for blocking or defining a subspace of the minimization. 
                It is better if the array is Fortran Aligned.
        """

        self.pols = pols.copy()
        self.nat = np.shape(self.pols)[0] / 3
        self.nmodes = np.shape(self.pols)[1]
        self.nq = np.shape(self.pols)[2]


    def CGF_ProjectOnModes(self, dyn_grad, struct_grad):
        """
        PROJECT THE GRADIENT IN THE SELECTED MODES
        ==========================================


        Function to be passed to the minimizer as 'custom_function_gradient'. 
        It project the gradients in the polarization vector subspace.
        As any custom_function_gradient, it takes as input the two gradients.
        """

        # Project the structure in the polarization vectors
        struct_grad_new = np.einsum("ai,bi,b", self.pols[:,:,0], self.pols[:,:,0], struct_grad.ravel())
        struct_grad = struct_grad_new.reshape((self.nat, 3))

        # Do the same for the matrix
        for iq in range(self.nq):
            for mu in range(self.nmodes):
                for nu in range(self.nmodes):
                    mat = np.outer(self.pols[:, mu, iq], np.conj(self.pols[:, nu, iq]))
                    dyn_grad[iq, :, :] = mat.dot( dyn_grad[iq, :, :].dot(np.matrix.getH(mat)))







