"""
This module contains the prefined custom function to
perform some standard variants of the minimization.

The function are classified as:
CGF : custom_gradient_function

"""
import cellconstructor as CC
import cellconstructor.Phonons
import numpy as np

class ModeProjection:
    def __init__(self, pols, masses_array):
        """
        This class is used to project the gradient in or out of
        a space generated by the mode in the pols array.
        
        The projection on the subspace is done in the following way.
        The force constant matrix is transformed in the dynamical matrix:
            
        .. math::
            
            D = M^{-\\frac 1 2} \\Phi M^{-\\frac 1 2}
            
            D_{proj} = \\sum_{\\mu} \\left|e_\\mu\\right> \\left<e_\\mu\\right| D \\left|e_\\mu\\right> \\left<e_\\mu\\right|
            
            \\Phi_{proj} = M^{\\frac 1 2} D_{proj} M^{\\frac 1 2}
            
        This means that the projection is done with the two operators
        
        .. math::
            
            \\Phi_{proj} = P^\\dagger \\Phi P
            
            P = \\sum_{\\mu} M^{-\\frac 12}\\left|e_\\mu\\right> \\left<e_\\mu\\right| M^{\\frac 12}
            
        The same matrix is used to project the vectors.

        Parameters
        ----------
            pols : ndarray( 3*nat, nmodes, nq)
                The modes to be used for blocking or defining a subspace of the minimization. 
                It is better if the array is Fortran Aligned.
            masses_array : ndarray (nat)
                The masses array for each atom in the structure.
        """
        
        if len(np.shape(pols)) != 3:
            raise ValueError("Error, note that the pols argument must have 3 indices: 3*nat, nmodes and iq")
        
        self.pols = pols.copy()  
        self.nat = np.shape(self.pols)[0] / 3
        self.nmodes = np.shape(self.pols)[1]
        self.nq = np.shape(self.pols)[2]
        
        # Check if the masses array is consistent
        if len(masses_array) != self.nat:
            raise ValueError("Error, the masses_array must have the dimension of the atom number")
        
        # Generate the array for the masses aligned as the polarization vector
        _m_ = np.tile(masses_array, (3, 1)).ravel(order = "F")
        _msq_ = np.sqrt(_m_)
        
        # Prepare the projector
        self.projector = np.zeros( (self.nq, 3*self.nat, 3*self.nat), dtype = np.complex128)
        self.projectorH = np.zeros( (self.nq, 3*self.nat, 3*self.nat), dtype = np.complex128)
        self.proj_vec = np.zeros( (3*self.nat, 3*self.nat), dtype = np.float64)

        for iq in range(self.nq):
            for mu in range(self.nmodes):
                pvec = self.pols[:, mu, iq]
                pvec /= pvec.dot(pvec) # Normalization
                self.projector[iq, :, :] += np.outer(pvec / _msq_, np.conj(pvec) * _msq_ )
                self.projectorH[iq, :, :] += np.outer(pvec*_msq_, np.conj(pvec) / _msq_)
                
        # Prepare the projector
        self.proj_vec[:,:] = np.real(self.projector[0, :, :])
                

        # Impose the sum rule 
        # Note that in principle it should be satisfied, however the python diagonalization
        # sucks, therefore the polarization vector are not exactly orthonormal.
        CC.symmetries.CustomASR(self.projector[0, :, :])

    def CFG_ProjectOnModes(self, dyn_grad, struct_grad):
        """
        PROJECT THE GRADIENT IN THE SELECTED MODES
        ==========================================


        Function to be passed to the minimizer as 'custom_function_gradient'. 
        It project the gradients in the polarization vector subspace.
        As any custom_function_gradient, it takes as input the two gradients.
        """

        # Project the structure in the polarization vectors
        struct_grad_new = self.proj_vec.dot(struct_grad.ravel())
        struct_grad = struct_grad_new.reshape((self.nat, 3))

        # Do the same for the matrix
        for iq in range(self.nq):
                    
            dyn_grad[iq, :, :] = self.projectorH[iq, :, :].dot(dyn_grad[iq, :, :].dot(self.projector[iq, :, :]))
            # Lets check if the matrix satisfy the sum rule
            #print "DIAG:", np.linalg.eigvalsh(dyn_grad[iq, :, :])
            
    def CFG_ProjectStructure(self, dyn_grad, struct_grad):
        """
        PROJECT ONLY THE STRUCTURE GRADIENT IN THE SELECTED MODES
        =========================================================
        
        This subroutine constraints only the structure gradient, leaving the
        dynamical matrix to minimize on all the possible degrees of freedom.
        """
        
        # Project the structure in the polarization vectors
        struct_grad_new = self.proj_vec.dot(struct_grad.ravel())
        struct_grad = struct_grad_new.reshape((self.nat, 3))
            
    def CFG_ProjectDyn(self, dyn_grad, struct_grad):
        """
        PROJECT ONLY THE FC GRADIENT IN THE SELECTED MODES
        ==================================================
        
        This subroutine constrains only the dynamical matrix, leaving the structure
        to minimize on all the possible degrees of freedom.
        """
        
        for iq in range(self.nq):
            dyn_grad[iq, :, :] = self.projectorH[iq, :, :].dot(dyn_grad[iq, :, :].dot(self.projector[iq, :, :]))







class IOInfo:
    def __init__(self):
        """
        This class is meant to deal with standard verbose I/O operation,
        like printing the frequencies as a function of the time step of a dynamical matrix (and so on)

        """

        self.total_freqs = []
        self.__save_fname = None
        self.__save_each_step = False

    def Reset(self):
        """
        Reset the data to empty.
        """

        self.__init__()

    def SetupSaving(self, fname, save_each_step = True):
        """
        Setup the system to save the data each time the function is called.

        Parameters
        ----------
            fname : string 
                path to the file to save the frequencies vs time
            save_each_step : bool
                If true the file is saved (and updated) each time step.

        """

        self.__save_fname = fname
        self.__save_each_step = save_each_step

    def Save(self, fname= None):
        """
        Save the data on a file
        
        Parameters
        ----------
            fname : string, optional
                If given, the file will be saved in the specified location.
                Otherwise the default one is used (must be initialized by SetupSaving)
        """
        if fname is None:
            if self.__save_fname is None:
                raise IOError("Error, a filename must be specified to save the frequencies.")
            np.savetxt(self.__save_fname, self.total_freqs, header = "Time vs Frequencies")
        else:
            np.savetxt(fname, self.total_freqs, header = "Time vs Frequencies")


    def CFP_SaveFrequencies(self, minim):
        """
        This custom method stores the total frequencies updating an exeternal file
        """
        
        # Generate the supercell in real space
        dyn_sc = minim.dyn.GenerateSupercellDyn( minim.ensemble.supercell )

        # Dyagonalize
        w, pols = dyn_sc.DyagDinQ(0)
        self.total_freqs.append(w)

        if self.__save_each_step:
            self.Save()
