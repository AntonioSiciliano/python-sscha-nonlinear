"""
This module contains the prefined custom function to
perform some standard variants of the minimization.

The function are classified as:
CGF : custom_gradient_function

"""
import cellconstructor as CC
import cellconstructor.Phonons
import numpy as np

class ModeProjection:
    def __init__(self, pols):
        """
        This class is used to project the gradient in or out of
        a space generated by the mode in the pols array.

        Parameters
        ----------
            pols : ndarray( 3*nat, nmodes, nq)
                The modes to be used for blocking or defining a subspace of the minimization. 
                It is better if the array is Fortran Aligned.
        """

        self.pols = pols.copy()
        self.nat = np.shape(self.pols)[0] / 3
        self.nmodes = np.shape(self.pols)[1]
        self.nq = np.shape(self.pols)[2]


    def CGF_ProjectOnModes(self, dyn_grad, struct_grad):
        """
        PROJECT THE GRADIENT IN THE SELECTED MODES
        ==========================================


        Function to be passed to the minimizer as 'custom_function_gradient'. 
        It project the gradients in the polarization vector subspace.
        As any custom_function_gradient, it takes as input the two gradients.
        """

        # Project the structure in the polarization vectors
        struct_grad_new = np.einsum("ai,bi,b", self.pols[:,:,0], self.pols[:,:,0], struct_grad.ravel())
        struct_grad = struct_grad_new.reshape((self.nat, 3))

        # Do the same for the matrix
        for iq in range(self.nq):
            for mu in range(self.nmodes):
                for nu in range(self.nmodes):
                    mat = np.outer(self.pols[:, mu, iq], np.conj(self.pols[:, nu, iq]))
                    mat_star = np.conj(np.transpose(mat))
                    dyn_grad[iq, :, :] = mat.dot( dyn_grad[iq, :, :].dot(mat_star))







class IOInfo:
    def __init__(self):
        """
        This class is meant to deal with standard verbose I/O operation,
        like printing the frequencies as a function of the time step of a dynamical matrix (and so on)

        """

        self.total_freqs = []
        self.__save_fname = None
        self.__save_each_step = False

    def Reset(self):
        """
        Reset the data to empty.
        """

        self.__init__()

    def SetupSaving(self, fname, save_each_step = True):
        """
        Setup the system to save the data each time the function is called.

        Parameters
        ----------
            fname : string 
                path to the file to save the frequencies vs time
            save_each_step : bool
                If true the file is saved (and updated) each time step.

        """

        self.__save_fname = fname
        self.__save_each_step = save_each_step

    def Save(self):
        """
        Save the data on a file
        """
        np.savetxt(self.__save_fname, self.total_freqs, header = "Time vs Frequencies")


    def CFP_SaveFrequencies(self, minim):
        """
        This custom method stores the total frequencies updating an exeternal file
        """
        
        # Generate the supercell in real space
        dyn_sc = minim.dyn.GetRealSpaceFC( minim.ens.supercell )

        # Dyagonalize
        w, pols = dyn_sc.DyagDinQ(0)
        self.total_freqs.append(w)

        if self.__save_each_step:
            self.Save()
